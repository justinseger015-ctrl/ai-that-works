const std = @import("std");
const ast = @import("ast.zig");
const Ast = ast.Ast;
const Declaration = ast.Declaration;
const ClassDecl = ast.ClassDecl;
const EnumDecl = ast.EnumDecl;
const FunctionDecl = ast.FunctionDecl;
const TypeExpr = ast.TypeExpr;
const Property = ast.Property;
const EnumValue = ast.EnumValue;
const Parameter = ast.Parameter;
const PrimitiveType = ast.PrimitiveType;

/// Helper function to check if a declaration has @@dynamic attribute
fn hasDynamicAttribute(attributes: *const std.ArrayList(ast.Attribute)) bool {
    for (attributes.items) |attr| {
        if (attr.is_class_level and std.mem.eql(u8, attr.name, "dynamic")) {
            return true;
        }
    }
    return false;
}

/// Python code generator
pub const PythonGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) PythonGenerator {
        return PythonGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Python code from AST
    pub fn generate(self: *PythonGenerator, tree: *const Ast) !void {
        // Write header with imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    /// Generate Python TypeBuilder module
    pub fn generateTypeBuilder(self: *PythonGenerator, tree: *const Ast) !void {
        // Write header
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("# TypeBuilder for dynamic types");
        try self.writeLine("");
        try self.writeLine("from typing import Optional, Any, Dict, List");
        try self.writeLine("");

        // Count dynamic types
        var has_dynamic_class = false;
        var has_dynamic_enum = false;
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| {
                    if (hasDynamicAttribute(&class.attributes)) {
                        has_dynamic_class = true;
                    }
                },
                .enum_decl => |enm| {
                    if (hasDynamicAttribute(&enm.attributes)) {
                        has_dynamic_enum = true;
                    }
                },
                else => {},
            }
        }

        // If no dynamic types, just create an empty TypeBuilder
        if (!has_dynamic_class and !has_dynamic_enum) {
            try self.writeLine("class TypeBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"TypeBuilder for runtime type modifications (no dynamic types defined)\"\"\"");
            try self.writeLine("pass");
            self.indent_level -= 1;
            return;
        }

        // Generate helper classes for dynamic types
        if (has_dynamic_class) {
            try self.writeLine("class DynamicClassBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Helper for building dynamic class properties at runtime\"\"\"");
            try self.writeLine("");
            try self.writeLine("def __init__(self, class_name: str):");
            self.indent_level += 1;
            try self.writeLine("self.class_name = class_name");
            try self.writeLine("self.properties: Dict[str, Any] = {}");
            self.indent_level -= 1;
            try self.writeLine("");
            try self.writeLine("def add_property(self, name: str, type_expr: Any, description: Optional[str] = None):");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Add a property to this dynamic class\"\"\"");
            try self.writeLine("self.properties[name] = {");
            self.indent_level += 1;
            try self.writeLine("'type': type_expr,");
            try self.writeLine("'description': description");
            self.indent_level -= 1;
            try self.writeLine("}");
            try self.writeLine("return self");
            self.indent_level -= 1;
            self.indent_level -= 1;
            try self.writeLine("");
        }

        if (has_dynamic_enum) {
            try self.writeLine("class DynamicEnumBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Helper for building dynamic enum values at runtime\"\"\"");
            try self.writeLine("");
            try self.writeLine("def __init__(self, enum_name: str):");
            self.indent_level += 1;
            try self.writeLine("self.enum_name = enum_name");
            try self.writeLine("self.values: List[str] = []");
            self.indent_level -= 1;
            try self.writeLine("");
            try self.writeLine("def add_value(self, value: str):");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Add a value to this dynamic enum\"\"\"");
            try self.writeLine("self.values.append(value)");
            try self.writeLine("return self");
            self.indent_level -= 1;
            self.indent_level -= 1;
            try self.writeLine("");
        }

        // Generate TypeBuilder class
        try self.writeLine("class TypeBuilder:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"TypeBuilder for runtime type modifications\"\"\"");
        try self.writeLine("");
        try self.writeLine("def __init__(self):");
        self.indent_level += 1;

        // Initialize dynamic class builders
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| {
                    if (hasDynamicAttribute(&class.attributes)) {
                        try self.writeIndent();
                        try self.write("self.");
                        try self.write(class.name);
                        try self.write(" = DynamicClassBuilder(\"");
                        try self.write(class.name);
                        try self.write("\")\n");
                    }
                },
                .enum_decl => |enm| {
                    if (hasDynamicAttribute(&enm.attributes)) {
                        try self.writeIndent();
                        try self.write("self.");
                        try self.write(enm.name);
                        try self.write(" = DynamicEnumBuilder(\"");
                        try self.write(enm.name);
                        try self.write("\")\n");
                    }
                },
                else => {},
            }
        }

        self.indent_level -= 1;
        try self.writeLine("");

        // Add type helper methods
        try self.writeLine("def string(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return string type\"\"\"");
        try self.writeLine("return 'string'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def int(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return int type\"\"\"");
        try self.writeLine("return 'int'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def float(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return float type\"\"\"");
        try self.writeLine("return 'float'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def bool(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return bool type\"\"\"");
        try self.writeLine("return 'bool'");
        self.indent_level -= 1;

        self.indent_level -= 1;
        try self.writeLine("");
    }

    fn writeHeader(self: *PythonGenerator) !void {
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("from typing import Optional, Union, List, Dict, Any");
        try self.writeLine("from pydantic import BaseModel, Field");
        try self.writeLine("from enum import Enum");
        try self.writeLine("");
    }

    fn generateClass(self: *PythonGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write class definition
        try self.write("class ");
        try self.write(class.name);
        try self.writeLine("(BaseModel):");

        self.indent_level += 1;

        // Handle empty class
        if (class.properties.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate properties
            for (class.properties.items) |prop| {
                try self.generateProperty(&prop);
            }
        }

        self.indent_level -= 1;
    }

    fn generateProperty(self: *PythonGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        // Write property name with indentation
        try self.writeIndent();
        try self.write(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        // Check for @alias attribute and add Field with alias
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.write(" = Field(alias=\"");
            try self.write(alias_name.?);
            try self.write("\")");
        }

        try self.write("\n");
    }

    fn generateEnum(self: *PythonGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write enum definition
        try self.write("class ");
        try self.write(enm.name);
        try self.writeLine("(str, Enum):");

        self.indent_level += 1;

        // Handle empty enum
        if (enm.values.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate enum values
            for (enm.values.items) |val| {
                try self.generateEnumValue(&val);
            }
        }

        self.indent_level -= 1;
    }

    fn generateEnumValue(self: *PythonGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"\n");
    }

    fn generateFunction(self: *PythonGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write function signature
        try self.write("def ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") -> ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(":");

        self.indent_level += 1;

        // Write function body (stub)
        if (func.prompt) |prompt| {
            try self.writeLine("\"\"\"");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.writeIndent();
                try self.buffer.appendSlice(self.allocator, line);
                try self.buffer.append(self.allocator, '\n');
            }
            try self.writeLine("\"\"\"");
        }

        try self.writeLine("raise NotImplementedError(\"This is a stub for LLM function\")");

        self.indent_level -= 1;
    }

    fn writeTypeAnnotation(self: *PythonGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const python_type = mapPrimitiveType(prim);
                try self.write(python_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .optional => |inner| {
                try self.write("Optional[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .union_type => |union_ty| {
                try self.write("Union[");
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeTypeAnnotation(ty);
                }
                try self.write("]");
            },
            .map => |map| {
                try self.write("Dict[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("]");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => |s| {
                        try self.write("\"");
                        try self.write(s);
                        try self.write("\"");
                    },
                    .int => |i| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{i});
                        try self.write(str);
                    },
                    .float => |f| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{f});
                        try self.write(str);
                    },
                    .bool => |b| {
                        try self.write(if (b) "True" else "False");
                    },
                    .null_value => {
                        try self.write("None");
                    },
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "str",
            .int => "int",
            .float => "float",
            .bool => "bool",
            .null_type => "None",
            .image => "Any",  // Image type as Any for now
            .audio => "Any",  // Audio type as Any for now
            .video => "Any",  // Video type as Any for now
            .pdf => "Any",    // PDF type as Any for now
        };
    }

    fn write(self: *PythonGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *PythonGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *PythonGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Tests
test "PythonGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Person(BaseModel):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: str") != null);
}

test "PythonGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Status(str, Enum):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = \"Active\"") != null);
}

test "PythonGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: Optional[int]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: List[str]") != null);
}

test "PythonGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Dict[str, str]") != null);
}

test "PythonGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Union[Person, None]") != null);
}

test "PythonGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "def Greet(p: Person) -> str:") != null);
}

test "PythonGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "email: str = Field(alias=\"email_address\")") != null);
}

/// TypeScript code generator
pub const TypeScriptGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) TypeScriptGenerator {
        return TypeScriptGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate TypeScript code from AST
    pub fn generate(self: *TypeScriptGenerator, tree: *const Ast) !void {
        // Write header with comments
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateInterface(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *TypeScriptGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
    }

    fn generateInterface(self: *TypeScriptGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write interface definition
        try self.write("export interface ");
        try self.write(class.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate properties
        for (class.properties.items) |prop| {
            try self.generateProperty(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateProperty(self: *TypeScriptGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write property name with indentation
        try self.writeIndent();

        // Check for @alias attribute
        var property_name = prop.name;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    property_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        try self.write(property_name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write(";\n");
    }

    fn generateEnum(self: *TypeScriptGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write enum definition
        try self.write("export enum ");
        try self.write(enm.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate enum values
        for (enm.values.items, 0..) |val, i| {
            try self.generateEnumValue(&val, i == enm.values.items.len - 1);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *TypeScriptGenerator, val: *const EnumValue, is_last: bool) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"");
        if (!is_last) {
            try self.write(",");
        }
        try self.write("\n");
    }

    fn generateFunction(self: *TypeScriptGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");

            // Add prompt as part of docstring if present
            if (func.prompt) |prompt| {
                try self.writeLine(" *");
                try self.writeLine(" * Prompt:");
                var lines = std.mem.splitSequence(u8, prompt, "\n");
                while (lines.next()) |line| {
                    try self.write(" * ");
                    try self.write(line);
                    try self.write("\n");
                }
            }

            try self.writeLine(" */");
        } else if (func.prompt) |prompt| {
            // No docstring but has prompt
            try self.writeLine("/**");
            try self.writeLine(" * Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write(" * ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine(" */");
        }

        // Write function signature
        try self.write("export function ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write("): ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(" {");

        self.indent_level += 1;
        try self.writeLine("throw new Error('This is a stub for LLM function');");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *TypeScriptGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const ts_type = mapPrimitiveType(prim);
                try self.write(ts_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write("[]");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write(" | undefined");
            },
            .union_type => |union_ty| {
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(" | ");
                    try self.writeTypeAnnotation(ty);
                }
            },
            .map => |map| {
                try self.write("Record<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => |s| {
                        try self.write("\"");
                        try self.write(s);
                        try self.write("\"");
                    },
                    .int => |i| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{i});
                        try self.write(str);
                    },
                    .float => |f| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{f});
                        try self.write(str);
                    },
                    .bool => |b| {
                        try self.write(if (b) "true" else "false");
                    },
                    .null_value => {
                        try self.write("null");
                    },
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "string",
            .int => "number",
            .float => "number",
            .bool => "boolean",
            .null_type => "null",
            .image => "any",  // Image type as any for now
            .audio => "any",  // Audio type as any for now
            .video => "any",  // Video type as any for now
            .pdf => "any",    // PDF type as any for now
        };
    }

    fn write(self: *TypeScriptGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *TypeScriptGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *TypeScriptGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// TypeScript Generator Tests
test "TypeScriptGenerator: simple interface" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export interface Person {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: string;") != null);
}

test "TypeScriptGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export enum Status {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = \"Active\"") != null);
}

test "TypeScriptGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: number | undefined;") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: string[];") != null);
}

test "TypeScriptGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Record<string, string>;") != null);
}

test "TypeScriptGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Person | null") != null);
}

test "TypeScriptGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export function Greet(p: Person): string {") != null);
}

test "TypeScriptGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "email_address: string;") != null);
}

// TypeBuilder Tests
test "PythonGenerator: TypeBuilder with no dynamic types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a simple class without @@dynamic
    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "no dynamic types defined") != null);
}

test "PythonGenerator: TypeBuilder with dynamic class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a class with @@dynamic
    var class_decl = ClassDecl.init(allocator, "User", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.attributes.append(allocator, attr);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicClassBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.User = DynamicClassBuilder(\"User\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def add_property") != null);
}

test "PythonGenerator: TypeBuilder with dynamic enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create an enum with @@dynamic
    var enum_decl = EnumDecl.init(allocator, "Category", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 3, .column = 3 },
    };
    try enum_decl.attributes.append(allocator, attr);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicEnumBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.Category = DynamicEnumBuilder(\"Category\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def add_value") != null);
}

test "PythonGenerator: TypeBuilder with multiple dynamic types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a dynamic class
    var class_decl = ClassDecl.init(allocator, "User", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    const class_attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.attributes.append(allocator, class_attr);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    // Create a dynamic enum
    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 5, .column = 1 });
    defer enum_decl.deinit(allocator);

    const enum_attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 6, .column = 3 },
    };
    try enum_decl.attributes.append(allocator, enum_attr);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicClassBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicEnumBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.User = DynamicClassBuilder(\"User\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.Status = DynamicEnumBuilder(\"Status\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def string(self)") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def int(self)") != null);
}

test "hasDynamicAttribute: detects @@dynamic" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer {
        for (attributes.items) |*attr| {
            attr.deinit(allocator);
        }
        attributes.deinit(allocator);
    }

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 1, .column = 1 },
    };
    try attributes.append(allocator, attr);

    try std.testing.expect(hasDynamicAttribute(&attributes) == true);
}

test "hasDynamicAttribute: ignores @dynamic (not class level)" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer {
        for (attributes.items) |*attr| {
            attr.deinit(allocator);
        }
        attributes.deinit(allocator);
    }

    // Add @dynamic attribute (not @@)
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = false, // Not class-level
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 1, .column = 1 },
    };
    try attributes.append(allocator, attr);

    try std.testing.expect(hasDynamicAttribute(&attributes) == false);
}

test "hasDynamicAttribute: returns false for no attributes" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer attributes.deinit(allocator);

    try std.testing.expect(hasDynamicAttribute(&attributes) == false);
}

/// Go code generator
pub const GoGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) GoGenerator {
        return GoGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Go code from AST
    pub fn generate(self: *GoGenerator, tree: *const Ast) !void {
        // Write header with package and imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateStruct(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *GoGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("package baml");
        try self.writeLine("");
        try self.writeLine("import (");
        self.indent_level += 1;
        try self.writeLine("\"errors\"");
        self.indent_level -= 1;
        try self.writeLine(")");
        try self.writeLine("");
    }

    fn generateStruct(self: *GoGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write struct definition
        try self.write("type ");
        try self.write(class.name);
        try self.writeLine(" struct {");

        self.indent_level += 1;

        // Generate fields
        for (class.properties.items) |prop| {
            try self.generateField(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateField(self: *GoGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();

        // Capitalize field name for export
        const first_char = prop.name[0];
        const capitalized = std.ascii.toUpper(first_char);
        try self.buffer.append(self.allocator, capitalized);
        if (prop.name.len > 1) {
            try self.write(prop.name[1..]);
        }

        try self.write(" ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        // Check for @alias attribute and add JSON tag
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        // Add JSON tag
        try self.write(" `json:\"");
        if (has_alias and alias_name != null) {
            try self.write(alias_name.?);
        } else {
            try self.write(prop.name);
        }
        try self.write("\"`");

        try self.write("\n");
    }

    fn generateEnum(self: *GoGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write enum type definition
        try self.write("type ");
        try self.write(enm.name);
        try self.writeLine(" string");
        try self.writeLine("");

        // Write enum constants
        try self.writeLine("const (");
        self.indent_level += 1;

        for (enm.values.items) |val| {
            try self.generateEnumValue(&val, enm.name);
        }

        self.indent_level -= 1;
        try self.writeLine(")");
    }

    fn generateEnumValue(self: *GoGenerator, val: *const EnumValue, enum_name: []const u8) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write(enum_name);
        try self.write(val.name);
        try self.write(" ");
        try self.write(enum_name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"\n");
    }

    fn generateFunction(self: *GoGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("// Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("// ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write function signature
        try self.write("func ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(" ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") (");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(", error) {");

        self.indent_level += 1;
        try self.writeLine("return *new(");
        try self.writeIndent();
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine("), errors.New(\"This is a stub for LLM function\")");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *GoGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const go_type = mapPrimitiveType(prim);
                try self.write(go_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("[]");
                try self.writeTypeAnnotation(inner);
            },
            .optional => |inner| {
                try self.write("*");
                try self.writeTypeAnnotation(inner);
            },
            .union_type => |union_ty| {
                // Go doesn't have union types, use interface{}
                if (union_ty.types.items.len == 2) {
                    // Check if one type is null - if so, use pointer
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.write("*");
                        try self.writeTypeAnnotation(non_null_type.?);
                    } else {
                        try self.write("interface{}");
                    }
                } else {
                    try self.write("interface{}");
                }
            },
            .map => |map| {
                try self.write("map[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write("]");
                try self.writeTypeAnnotation(map.value_type);
            },
            .literal => |lit| {
                // Literals in Go are just their types
                switch (lit) {
                    .string => try self.write("string"),
                    .int => try self.write("int"),
                    .float => try self.write("float64"),
                    .bool => try self.write("bool"),
                    .null_value => try self.write("interface{}"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "string",
            .int => "int",
            .float => "float64",
            .bool => "bool",
            .null_type => "interface{}",
            .image => "interface{}",  // Image type as interface{} for now
            .audio => "interface{}",  // Audio type as interface{} for now
            .video => "interface{}",  // Video type as interface{} for now
            .pdf => "interface{}",    // PDF type as interface{} for now
        };
    }

    fn write(self: *GoGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *GoGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *GoGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "\t");
        }
    }
};

// Go Generator Tests
test "GoGenerator: simple struct" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "type Person struct {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Name string") != null);
}

test "GoGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "type Status string") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "StatusActive Status = \"Active\"") != null);
}

test "GoGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Age *int") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Tags []string") != null);
}

test "GoGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Metadata map[string]string") != null);
}

test "GoGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "func Greet(p Person) (string, error)") != null);
}

test "GoGenerator: field with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Email string `json:\"email_address\"`") != null);
}

/// Ruby code generator
pub const RubyGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) RubyGenerator {
        return RubyGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Ruby code from AST
    pub fn generate(self: *RubyGenerator, tree: *const Ast) !void {
        // Write header with comments
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *RubyGenerator) !void {
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("# frozen_string_literal: true");
        try self.writeLine("");
    }

    fn generateClass(self: *RubyGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write class definition
        try self.write("class ");
        try self.write(class.name);
        try self.writeLine("");

        self.indent_level += 1;

        // Generate attr_accessor for all properties
        if (class.properties.items.len > 0) {
            try self.writeIndent();
            try self.write("attr_accessor ");
            for (class.properties.items, 0..) |prop, i| {
                if (i > 0) try self.write(", ");
                try self.write(":");
                // Check for @alias attribute
                var property_name = prop.name;
                for (prop.attributes.items) |attr| {
                    if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                        if (attr.args.items[0] == .string) {
                            property_name = attr.args.items[0].string;
                            break;
                        }
                    }
                }
                try self.write(property_name);
            }
            try self.write("\n\n");

            // Generate initialize method with type comments
            try self.writeLine("# @param args [Hash] Initialization arguments");
            try self.writeLine("def initialize(**args)");
            self.indent_level += 1;

            for (class.properties.items) |prop| {
                try self.writeIndent();
                try self.write("@");
                // Use alias if present
                var property_name = prop.name;
                for (prop.attributes.items) |attr| {
                    if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                        if (attr.args.items[0] == .string) {
                            property_name = attr.args.items[0].string;
                            break;
                        }
                    }
                }
                try self.write(property_name);
                try self.write(" = args[:");
                try self.write(property_name);
                try self.write("]\n");
            }

            self.indent_level -= 1;
            try self.writeLine("end");
        }

        self.indent_level -= 1;
        try self.writeLine("end");
    }

    fn generateEnum(self: *RubyGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write module definition for enum
        try self.write("module ");
        try self.write(enm.name);
        try self.writeLine("");

        self.indent_level += 1;

        // Generate constants for each value
        for (enm.values.items) |val| {
            try self.generateEnumValue(&val);
        }

        // Generate ALL constant with all values
        try self.writeLine("");
        try self.writeIndent();
        try self.write("ALL = [");
        for (enm.values.items, 0..) |val, i| {
            if (i > 0) try self.write(", ");
            try self.write(val.name);
        }
        try self.write("].freeze\n");

        self.indent_level -= 1;
        try self.writeLine("end");
    }

    fn generateEnumValue(self: *RubyGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = '");
        try self.write(val.name);
        try self.write("'.freeze\n");
    }

    fn generateFunction(self: *RubyGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write YARD-style type documentation
        for (func.parameters.items) |param| {
            try self.write("# @param ");
            try self.write(param.name);
            try self.write(" [");
            try self.writeTypeAnnotation(param.type_expr);
            try self.write("]\n");
        }

        try self.write("# @return [");
        try self.writeTypeAnnotation(func.return_type);
        try self.write("]\n");

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("# Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("# ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write function definition
        try self.write("def ");

        // Convert to snake_case for Ruby convention
        try self.writeSnakeCase(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
        }

        try self.writeLine(")");

        self.indent_level += 1;
        try self.writeLine("raise NotImplementedError, 'This is a stub for LLM function'");
        self.indent_level -= 1;

        try self.writeLine("end");
    }

    fn writeTypeAnnotation(self: *RubyGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const ruby_type = mapPrimitiveType(prim);
                try self.write(ruby_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("Array<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write(", nil");
            },
            .union_type => |union_ty| {
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeTypeAnnotation(ty);
                }
            },
            .map => |map| {
                try self.write("Hash{");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(" => ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("}");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("Integer"),
                    .float => try self.write("Float"),
                    .bool => try self.write("Boolean"),
                    .null_value => try self.write("nil"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "Integer",
            .float => "Float",
            .bool => "Boolean",
            .null_type => "nil",
            .image => "Object",  // Image type as Object for now
            .audio => "Object",  // Audio type as Object for now
            .video => "Object",  // Video type as Object for now
            .pdf => "Object",    // PDF type as Object for now
        };
    }

    fn writeSnakeCase(self: *RubyGenerator, name: []const u8) !void {
        // Convert PascalCase/camelCase to snake_case
        for (name, 0..) |c, i| {
            if (std.ascii.isUpper(c)) {
                if (i > 0) {
                    try self.buffer.append(self.allocator, '_');
                }
                try self.buffer.append(self.allocator, std.ascii.toLower(c));
            } else {
                try self.buffer.append(self.allocator, c);
            }
        }
    }

    fn write(self: *RubyGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *RubyGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *RubyGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// Ruby Generator Tests
test "RubyGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Person") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :name") != null);
}

test "RubyGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "module Status") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = 'Active'.freeze") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "ALL = [Active].freeze") != null);
}

test "RubyGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :age, :tags") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def initialize") != null);
}

test "RubyGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "def greet(p)") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# @param p [Person]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# @return [String]") != null);
}

test "RubyGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :metadata") != null);
}

test "RubyGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :email_address") != null);
}

/// Rust code generator
pub const RustGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) RustGenerator {
        return RustGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Rust code from AST
    pub fn generate(self: *RustGenerator, tree: *const Ast) !void {
        // Write header with comments and use statements
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateStruct(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *RustGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("use serde::{Deserialize, Serialize};");
        try self.writeLine("use std::collections::HashMap;");
        try self.writeLine("use std::error::Error;");
        try self.writeLine("");
    }

    fn generateStruct(self: *RustGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeLine("/// ");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
        }

        // Write derives
        try self.writeLine("#[derive(Debug, Clone, Serialize, Deserialize)]");

        // Write struct definition
        try self.write("pub struct ");
        try self.write(class.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate fields
        for (class.properties.items) |prop| {
            try self.generateField(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateField(self: *RustGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Check for @alias attribute and add serde rename
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.writeIndent();
            try self.write("#[serde(rename = \"");
            try self.write(alias_name.?);
            try self.write("\")]\n");
        }

        try self.writeIndent();
        try self.write("pub ");
        try self.writeSnakeCase(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write(",\n");
    }

    fn generateEnum(self: *RustGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeLine("/// ");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
        }

        // Write derives
        try self.writeLine("#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]");

        // Write enum definition
        try self.write("pub enum ");
        try self.write(enm.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate enum variants
        for (enm.values.items) |val| {
            try self.generateEnumValue(&val);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *RustGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(",\n");
    }

    fn generateFunction(self: *RustGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeLine("/// ");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
        }

        // If there's a prompt, add it as a doc comment
        if (func.prompt) |prompt| {
            try self.writeLine("///");
            try self.writeLine("/// # Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("/// ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write function signature
        try self.write("pub fn ");
        try self.writeSnakeCase(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.writeSnakeCase(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") -> Result<");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(", Box<dyn Error>> {");

        self.indent_level += 1;
        try self.writeLine("Err(\"This is a stub for LLM function\".into())");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *RustGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const rust_type = mapPrimitiveType(prim);
                try self.write(rust_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("Vec<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .optional => |inner| {
                try self.write("Option<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .union_type => |union_ty| {
                // Rust doesn't have union types like TypeScript
                // Check if one type is null - if so, use Option
                if (union_ty.types.items.len == 2) {
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.write("Option<");
                        try self.writeTypeAnnotation(non_null_type.?);
                        try self.write(">");
                    } else {
                        // Both are null? Just use unit type
                        try self.write("()");
                    }
                } else {
                    // Multiple non-null types - use Box<dyn Any> as fallback
                    try self.write("Box<dyn std::any::Any>");
                }
            },
            .map => |map| {
                try self.write("HashMap<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                // Literals in Rust are just their types
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("i64"),
                    .float => try self.write("f64"),
                    .bool => try self.write("bool"),
                    .null_value => try self.write("()"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "i64",
            .float => "f64",
            .bool => "bool",
            .null_type => "()",
            .image => "Vec<u8>",  // Image type as byte array
            .audio => "Vec<u8>",  // Audio type as byte array
            .video => "Vec<u8>",  // Video type as byte array
            .pdf => "Vec<u8>",    // PDF type as byte array
        };
    }

    fn writeSnakeCase(self: *RustGenerator, name: []const u8) !void {
        // Convert PascalCase/camelCase to snake_case
        for (name, 0..) |c, i| {
            if (std.ascii.isUpper(c)) {
                if (i > 0) {
                    try self.buffer.append(self.allocator, '_');
                }
                try self.buffer.append(self.allocator, std.ascii.toLower(c));
            } else {
                try self.buffer.append(self.allocator, c);
            }
        }
    }

    fn write(self: *RustGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *RustGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *RustGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Rust Generator Tests
test "RustGenerator: simple struct" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub struct Person {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "pub name: String,") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "#[derive(Debug, Clone, Serialize, Deserialize)]") != null);
}

test "RustGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub enum Status {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active,") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]") != null);
}

test "RustGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub age: Option<i64>,") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "pub tags: Vec<String>,") != null);
}

test "RustGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub metadata: HashMap<String, String>,") != null);
}

test "RustGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub fn greet(p: Person) -> Result<String, Box<dyn Error>> {") != null);
}

test "RustGenerator: field with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "#[serde(rename = \"email_address\")]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "pub email: String,") != null);
}
/// Elixir code generator
pub const ElixirGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) ElixirGenerator {
        return ElixirGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Elixir code from AST
    pub fn generate(self: *ElixirGenerator, tree: *const Ast) !void {
        // Write header with comments
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateModule(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *ElixirGenerator) !void {
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
    }

    fn generateModule(self: *ElixirGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeIndent();
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write module definition
        try self.write("defmodule ");
        try self.write(class.name);
        try self.writeLine(" do");

        self.indent_level += 1;

        // Write @type definition
        try self.writeIndent();
        try self.write("@type t :: %__MODULE__{");
        if (class.properties.items.len > 0) {
            try self.write("\n");
            self.indent_level += 1;
            for (class.properties.items, 0..) |prop, i| {
                try self.writeIndent();
                try self.writeAtomName(prop.name, &prop.attributes);
                try self.write(": ");
                try self.writeTypeAnnotation(prop.type_expr);
                if (i < class.properties.items.len - 1) {
                    try self.write(",");
                }
                try self.write("\n");
            }
            self.indent_level -= 1;
            try self.writeIndent();
            try self.writeLine("}");
        } else {
            try self.writeLine("}");
        }

        try self.writeLine("");

        // Write defstruct
        try self.writeIndent();
        try self.write("defstruct [");
        if (class.properties.items.len > 0) {
            for (class.properties.items, 0..) |prop, i| {
                try self.write(":");
                try self.writeFieldName(prop.name, &prop.attributes);
                if (i < class.properties.items.len - 1) {
                    try self.write(", ");
                }
            }
        }
        try self.writeLine("]");

        self.indent_level -= 1;
        try self.writeLine("end");
    }

    fn generateEnum(self: *ElixirGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeIndent();
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write module definition
        try self.write("defmodule ");
        try self.write(enm.name);
        try self.writeLine(" do");

        self.indent_level += 1;

        // Write @type definition with atom union
        try self.writeIndent();
        try self.write("@type t :: ");
        for (enm.values.items, 0..) |val, i| {
            try self.write(":");
            try self.writeSnakeCase(val.name);
            if (i < enm.values.items.len - 1) {
                try self.write(" | ");
            }
        }
        try self.writeLine("");

        try self.writeLine("");

        // Write values/0 function
        try self.writeIndent();
        try self.write("def values, do: [");
        for (enm.values.items, 0..) |val, i| {
            try self.write(":");
            try self.writeSnakeCase(val.name);
            if (i < enm.values.items.len - 1) {
                try self.write(", ");
            }
        }
        try self.writeLine("]");

        self.indent_level -= 1;
        try self.writeLine("end");
    }

    fn generateFunction(self: *ElixirGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeIndent();
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("#");
            try self.writeLine("# Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("# ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write @spec
        try self.write("@spec ");
        try self.writeSnakeCase(func.name);
        try self.write("(");
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.writeTypeAnnotation(param.type_expr);
        }
        try self.write(") :: ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine("");

        // Write function definition
        try self.write("def ");
        try self.writeSnakeCase(func.name);
        try self.write("(");
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.writeSnakeCase(param.name);
        }
        try self.writeLine(") do");

        self.indent_level += 1;
        try self.writeLine("raise \"This is a stub for LLM function\"");
        self.indent_level -= 1;

        try self.writeLine("end");
    }

    fn writeTypeAnnotation(self: *ElixirGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const elixir_type = mapPrimitiveType(prim);
                try self.write(elixir_type);
            },
            .named => |name| {
                try self.write(name);
                try self.write(".t()");
            },
            .array => |inner| {
                try self.write("list(");
                try self.writeTypeAnnotation(inner);
                try self.write(")");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write(" | nil");
            },
            .union_type => |union_ty| {
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(" | ");
                    try self.writeTypeAnnotation(ty);
                }
            },
            .map => |map| {
                try self.write("%{");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(" => ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("}");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => try self.write("String.t()"),
                    .int => try self.write("integer()"),
                    .float => try self.write("float()"),
                    .bool => try self.write("boolean()"),
                    .null_value => try self.write("nil"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String.t()",
            .int => "integer()",
            .float => "float()",
            .bool => "boolean()",
            .null_type => "nil",
            .image => "binary()",  // Image type as binary
            .audio => "binary()",  // Audio type as binary
            .video => "binary()",  // Video type as binary
            .pdf => "binary()",    // PDF type as binary
        };
    }

    fn writeSnakeCase(self: *ElixirGenerator, name: []const u8) !void {
        // Convert PascalCase/camelCase to snake_case
        for (name, 0..) |c, i| {
            if (std.ascii.isUpper(c)) {
                if (i > 0) {
                    try self.buffer.append(self.allocator, '_');
                }
                try self.buffer.append(self.allocator, std.ascii.toLower(c));
            } else {
                try self.buffer.append(self.allocator, c);
            }
        }
    }

    fn writeAtomName(self: *ElixirGenerator, name: []const u8, attributes: *const std.ArrayList(ast.Attribute)) !void {
        // Check for @alias attribute
        for (attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    try self.writeSnakeCase(attr.args.items[0].string);
                    return;
                }
            }
        }
        // No alias, use the name as-is (converted to snake_case)
        try self.writeSnakeCase(name);
    }

    fn writeFieldName(self: *ElixirGenerator, name: []const u8, attributes: *const std.ArrayList(ast.Attribute)) !void {
        // Check for @alias attribute
        for (attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    try self.writeSnakeCase(attr.args.items[0].string);
                    return;
                }
            }
        }
        // No alias, use the name as-is (converted to snake_case)
        try self.writeSnakeCase(name);
    }

    fn write(self: *ElixirGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *ElixirGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *ElixirGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// Elixir Generator Tests
test "ElixirGenerator: simple module" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ElixirGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "defmodule Person do") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "@type t :: %__MODULE__{") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: String.t()") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "defstruct [:name]") != null);
}

test "ElixirGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    const inactive = EnumValue{
        .name = "Inactive",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try enum_decl.values.append(allocator, inactive);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ElixirGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "defmodule Status do") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "@type t :: :active | :inactive") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def values, do: [:active, :inactive]") != null);
}

test "ElixirGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ElixirGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: integer() | nil") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: list(String.t())") != null);
}

test "ElixirGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ElixirGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: %{String.t() => String.t()}") != null);
}

test "ElixirGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ElixirGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "@spec greet(Person.t()) :: String.t()") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def greet(p) do") != null);
}

test "ElixirGenerator: field with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ElixirGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "defstruct [:email_address]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "email_address: String.t()") != null);
}

/// Java code generator
pub const JavaGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) JavaGenerator {
        return JavaGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Java code from AST
    pub fn generate(self: *JavaGenerator, tree: *const Ast) !void {
        // Write header with package and imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *JavaGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("package com.baml.generated;");
        try self.writeLine("");
        try self.writeLine("import java.util.List;");
        try self.writeLine("import java.util.Map;");
        try self.writeLine("import java.util.Optional;");
        try self.writeLine("import com.fasterxml.jackson.annotation.JsonProperty;");
        try self.writeLine("");
    }

    fn generateClass(self: *JavaGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("/** ");
            try self.write(doc);
            try self.write(" */\n");
        }

        // Write class definition
        try self.write("public class ");
        try self.write(class.name);
        try self.write(" {\n");

        self.indent_level += 1;

        // Generate fields
        for (class.properties.items) |prop| {
            try self.generateField(&prop);
        }

        // Generate constructor
        try self.writeLine("");
        try self.writeIndent();
        try self.write("public ");
        try self.write(class.name);
        try self.write("() {}\n");

        // Generate getters and setters
        for (class.properties.items) |prop| {
            try self.generateGetterSetter(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateField(self: *JavaGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("/** ");
            try self.write(doc);
            try self.write(" */\n");
        }

        // Check for @alias attribute and add Jackson annotation
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.writeIndent();
            try self.write("@JsonProperty(\"");
            try self.write(alias_name.?);
            try self.write("\")\n");
        }

        try self.writeIndent();
        try self.write("private ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write(" ");
        try self.write(prop.name);
        try self.write(";\n");
    }

    fn generateGetterSetter(self: *JavaGenerator, prop: *const Property) !void {
        try self.writeLine("");

        // Getter
        try self.writeIndent();
        try self.write("public ");
        try self.writeTypeAnnotation(prop.type_expr);
        try self.write(" get");

        // Capitalize first letter of property name
        const first_char = prop.name[0];
        const capitalized = std.ascii.toUpper(first_char);
        try self.buffer.append(self.allocator, capitalized);
        if (prop.name.len > 1) {
            try self.write(prop.name[1..]);
        }

        try self.write("() {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("return this.");
        try self.write(prop.name);
        try self.write(";\n");
        self.indent_level -= 1;
        try self.writeLine("}");

        try self.writeLine("");

        // Setter
        try self.writeIndent();
        try self.write("public void set");

        // Capitalize first letter of property name
        try self.buffer.append(self.allocator, capitalized);
        if (prop.name.len > 1) {
            try self.write(prop.name[1..]);
        }

        try self.write("(");
        try self.writeTypeAnnotation(prop.type_expr);
        try self.write(" ");
        try self.write(prop.name);
        try self.write(") {\n");
        self.indent_level += 1;
        try self.writeIndent();
        try self.write("this.");
        try self.write(prop.name);
        try self.write(" = ");
        try self.write(prop.name);
        try self.write(";\n");
        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnum(self: *JavaGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("/** ");
            try self.write(doc);
            try self.write(" */\n");
        }

        // Write enum definition
        try self.write("public enum ");
        try self.write(enm.name);
        try self.write(" {\n");

        self.indent_level += 1;

        // Write enum values
        for (enm.values.items, 0..) |val, i| {
            try self.generateEnumValue(&val);
            if (i < enm.values.items.len - 1) {
                try self.write(",\n");
            } else {
                try self.write("\n");
            }
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *JavaGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("/** ");
            try self.write(doc);
            try self.write(" */\n");
        }

        try self.writeIndent();
        try self.write(val.name);
    }

    fn generateFunction(self: *JavaGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("/** ");
            try self.write(doc);
            try self.write(" */\n");
        }

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("/**");
            try self.writeLine(" * Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write(" * ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine(" */");
        }

        // Write function signature
        try self.write("public static ");
        try self.writeTypeAnnotation(func.return_type);
        try self.write(" ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.writeTypeAnnotation(param.type_expr);
            try self.write(" ");
            try self.write(param.name);
        }

        try self.write(") {\n");

        self.indent_level += 1;
        try self.writeLine("throw new UnsupportedOperationException(\"This is a stub for LLM function\");");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *JavaGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const java_type = mapPrimitiveType(prim);
                try self.write(java_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .optional => |inner| {
                try self.write("Optional<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .union_type => |union_ty| {
                // Java doesn't have union types, use Object as fallback
                if (union_ty.types.items.len == 2) {
                    // Check if one type is null - if so, use Optional
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.write("Optional<");
                        try self.writeTypeAnnotation(non_null_type.?);
                        try self.write(">");
                    } else {
                        try self.write("Object");
                    }
                } else {
                    try self.write("Object");
                }
            },
            .map => |map| {
                try self.write("Map<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                // Literals in Java are just their types
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("Integer"),
                    .float => try self.write("Double"),
                    .bool => try self.write("Boolean"),
                    .null_value => try self.write("Object"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "Integer",
            .float => "Double",
            .bool => "Boolean",
            .null_type => "Object",
            .image => "byte[]",    // Image type as byte array
            .audio => "byte[]",    // Audio type as byte array
            .video => "byte[]",    // Video type as byte array
            .pdf => "byte[]",      // PDF type as byte array
        };
    }

    fn write(self: *JavaGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *JavaGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *JavaGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Java Generator Tests
test "JavaGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = JavaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public class Person {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "private String name;") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public String getName()") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public void setName(String name)") != null);
}

test "JavaGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = JavaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public enum Status {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active") != null);
}

test "JavaGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = JavaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "private Optional<Integer> age;") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "private List<String> tags;") != null);
}

test "JavaGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = JavaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "private Map<String, String> metadata;") != null);
}

test "JavaGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = JavaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public static String Greet(Person p)") != null);
}

test "JavaGenerator: field with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = JavaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "@JsonProperty(\"email_address\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "private String email;") != null);
}

/// C# code generator
pub const CSharpGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) CSharpGenerator {
        return CSharpGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate C# code from AST
    pub fn generate(self: *CSharpGenerator, tree: *const Ast) !void {
        // Write header with using statements
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *CSharpGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("using System;");
        try self.writeLine("using System.Collections.Generic;");
        try self.writeLine("using System.Text.Json.Serialization;");
        try self.writeLine("");
    }

    fn generateClass(self: *CSharpGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("/// <summary>");
            try self.write(doc);
            try self.write("</summary>\n");
        }

        // Write class definition
        try self.write("public class ");
        try self.write(class.name);
        try self.write("\n");
        try self.writeLine("{");

        self.indent_level += 1;

        // Generate properties
        for (class.properties.items) |prop| {
            try self.generateProperty(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateProperty(self: *CSharpGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// <summary>");
            try self.write(doc);
            try self.write("</summary>\n");
        }

        // Check for @alias attribute and add JsonPropertyName annotation
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.writeIndent();
            try self.write("[JsonPropertyName(\"");
            try self.write(alias_name.?);
            try self.write("\")]\n");
        }

        try self.writeIndent();
        try self.write("public ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write(" ");

        // Capitalize first letter for C# convention
        const first_char = prop.name[0];
        const capitalized = std.ascii.toUpper(first_char);
        try self.buffer.append(self.allocator, capitalized);
        if (prop.name.len > 1) {
            try self.write(prop.name[1..]);
        }

        try self.write(" { get; set; }\n");
    }

    fn generateEnum(self: *CSharpGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("/// <summary>");
            try self.write(doc);
            try self.write("</summary>\n");
        }

        // Write enum definition
        try self.write("public enum ");
        try self.write(enm.name);
        try self.write("\n");
        try self.writeLine("{");

        self.indent_level += 1;

        // Write enum values
        for (enm.values.items, 0..) |val, i| {
            try self.generateEnumValue(&val);
            if (i < enm.values.items.len - 1) {
                try self.write(",\n");
            } else {
                try self.write("\n");
            }
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *CSharpGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// <summary>");
            try self.write(doc);
            try self.write("</summary>\n");
        }

        try self.writeIndent();
        try self.write(val.name);
    }

    fn generateFunction(self: *CSharpGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("/// <summary>");
            try self.write(doc);
            try self.write("</summary>\n");
        }

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("/// <remarks>");
            try self.writeLine("/// Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("/// ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine("/// </remarks>");
        }

        // Write function signature
        try self.write("public static ");
        try self.writeTypeAnnotation(func.return_type);
        try self.write(" ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.writeTypeAnnotation(param.type_expr);
            try self.write(" ");
            try self.write(param.name);
        }

        try self.write(")\n");
        try self.writeLine("{");

        self.indent_level += 1;
        try self.writeLine("throw new NotImplementedException(\"This is a stub for LLM function\");");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *CSharpGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const csharp_type = mapPrimitiveType(prim);
                try self.write(csharp_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write("?");
            },
            .union_type => |union_ty| {
                // C# doesn't have union types, use nullable or object
                if (union_ty.types.items.len == 2) {
                    // Check if one type is null - if so, use nullable
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.writeTypeAnnotation(non_null_type.?);
                        try self.write("?");
                    } else {
                        try self.write("object");
                    }
                } else {
                    try self.write("object");
                }
            },
            .map => |map| {
                try self.write("Dictionary<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                // Literals in C# are just their types
                switch (lit) {
                    .string => try self.write("string"),
                    .int => try self.write("int"),
                    .float => try self.write("double"),
                    .bool => try self.write("bool"),
                    .null_value => try self.write("object"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "string",
            .int => "int",
            .float => "double",
            .bool => "bool",
            .null_type => "object",
            .image => "byte[]",    // Image type as byte array
            .audio => "byte[]",    // Audio type as byte array
            .video => "byte[]",    // Video type as byte array
            .pdf => "byte[]",      // PDF type as byte array
        };
    }

    fn write(self: *CSharpGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *CSharpGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *CSharpGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// C# Generator Tests
test "CSharpGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = CSharpGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public class Person") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public string Name { get; set; }") != null);
}

test "CSharpGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = CSharpGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public enum Status") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active") != null);
}

test "CSharpGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = CSharpGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public int? Age { get; set; }") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public List<string> Tags { get; set; }") != null);
}

test "CSharpGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = CSharpGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public Dictionary<string, string> Metadata { get; set; }") != null);
}

test "CSharpGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = CSharpGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public static string Greet(Person p)") != null);
}

test "CSharpGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = CSharpGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "[JsonPropertyName(\"email_address\")]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public string Email { get; set; }") != null);
}

/// Swift code generator
pub const SwiftGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) SwiftGenerator {
        return SwiftGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Swift code from AST
    pub fn generate(self: *SwiftGenerator, tree: *const Ast) !void {
        // Write header with import statements
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateStruct(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *SwiftGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("import Foundation");
        try self.writeLine("");
    }

    fn generateStruct(self: *SwiftGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write struct definition with Codable
        try self.write("struct ");
        try self.write(class.name);
        try self.writeLine(": Codable {");

        self.indent_level += 1;

        // Check if any property has an alias (need CodingKeys)
        var has_alias = false;
        for (class.properties.items) |prop| {
            for (prop.attributes.items) |attr| {
                if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                    has_alias = true;
                    break;
                }
            }
            if (has_alias) break;
        }

        // Generate properties
        for (class.properties.items) |prop| {
            try self.generateProperty(&prop);
        }

        // Generate CodingKeys enum if needed
        if (has_alias) {
            try self.writeLine("");
            try self.writeLine("enum CodingKeys: String, CodingKey {");
            self.indent_level += 1;
            for (class.properties.items) |prop| {
                try self.writeIndent();
                try self.write("case ");
                try self.write(prop.name);

                // Check for alias
                for (prop.attributes.items) |attr| {
                    if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                        if (attr.args.items[0] == .string) {
                            try self.write(" = \"");
                            try self.write(attr.args.items[0].string);
                            try self.write("\"");
                            break;
                        }
                    }
                }
                try self.write("\n");
            }
            self.indent_level -= 1;
            try self.writeLine("}");
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateProperty(self: *SwiftGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write("let ");
        try self.write(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write("\n");
    }

    fn generateEnum(self: *SwiftGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write enum definition with String raw values
        try self.write("enum ");
        try self.write(enm.name);
        try self.writeLine(": String, Codable {");

        self.indent_level += 1;

        // Generate enum cases
        for (enm.values.items) |val| {
            try self.generateEnumValue(&val);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *SwiftGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write("case ");

        // Convert first letter to lowercase for Swift convention
        const first_char = val.name[0];
        const lowercase = std.ascii.toLower(first_char);
        try self.buffer.append(self.allocator, lowercase);
        if (val.name.len > 1) {
            try self.write(val.name[1..]);
        }

        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"\n");
    }

    fn generateFunction(self: *SwiftGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Add parameters and return type documentation
        if (func.parameters.items.len > 0) {
            for (func.parameters.items) |param| {
                try self.write("/// - Parameter ");
                try self.write(param.name);
                try self.write(": ");
                try self.writeTypeAnnotation(param.type_expr);
                try self.write("\n");
            }
        }

        try self.write("/// - Returns: ");
        try self.writeTypeAnnotation(func.return_type);
        try self.write("\n");

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("///");
            try self.writeLine("/// Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("/// ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write function signature
        try self.write("func ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") throws -> ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(" {");

        self.indent_level += 1;
        try self.writeLine("throw NSError(domain: \"minibaml\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"This is a stub for LLM function\"])");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *SwiftGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const swift_type = mapPrimitiveType(prim);
                try self.write(swift_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write("?");
            },
            .union_type => |union_ty| {
                // Swift doesn't have union types like TypeScript
                // Check if one type is null - if so, use optional
                if (union_ty.types.items.len == 2) {
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.writeTypeAnnotation(non_null_type.?);
                        try self.write("?");
                    } else {
                        try self.write("Any");
                    }
                } else {
                    try self.write("Any");
                }
            },
            .map => |map| {
                try self.write("[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(": ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("]");
            },
            .literal => |lit| {
                // Literals in Swift are just their types
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("Int"),
                    .float => try self.write("Double"),
                    .bool => try self.write("Bool"),
                    .null_value => try self.write("Any"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "Int",
            .float => "Double",
            .bool => "Bool",
            .null_type => "Any",
            .image => "Data",    // Image type as Data (byte array)
            .audio => "Data",    // Audio type as Data (byte array)
            .video => "Data",    // Video type as Data (byte array)
            .pdf => "Data",      // PDF type as Data (byte array)
        };
    }

    fn write(self: *SwiftGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *SwiftGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *SwiftGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Swift Generator Tests
test "SwiftGenerator: simple struct" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = SwiftGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "struct Person: Codable {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "let name: String") != null);
}

test "SwiftGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = SwiftGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "enum Status: String, Codable {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "case active = \"Active\"") != null);
}

test "SwiftGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = SwiftGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "let age: Int?") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "let tags: [String]") != null);
}

test "SwiftGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = SwiftGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "let metadata: [String: String]") != null);
}

test "SwiftGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = SwiftGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "func Greet(p: Person) throws -> String {") != null);
}

test "SwiftGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = SwiftGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "case email = \"email_address\"") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "enum CodingKeys: String, CodingKey {") != null);
}
/// Kotlin code generator
pub const KotlinGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) KotlinGenerator {
        return KotlinGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Kotlin code from AST
    pub fn generate(self: *KotlinGenerator, tree: *const Ast) !void {
        // Write header with package and imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateDataClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *KotlinGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("package com.baml.generated");
        try self.writeLine("");
        try self.writeLine("import com.fasterxml.jackson.annotation.JsonProperty");
        try self.writeLine("");
    }

    fn generateDataClass(self: *KotlinGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("/**");
            try self.write("\n");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.write(" */");
            try self.write("\n");
        }

        // Write data class definition
        try self.write("data class ");
        try self.write(class.name);
        try self.write("(");

        // Generate properties in constructor
        if (class.properties.items.len > 0) {
            try self.write("\n");
            self.indent_level += 1;

            for (class.properties.items, 0..) |prop, i| {
                try self.generateProperty(&prop);
                if (i < class.properties.items.len - 1) {
                    try self.write(",\n");
                } else {
                    try self.write("\n");
                }
            }

            self.indent_level -= 1;
        }

        try self.writeLine(")");
    }

    fn generateProperty(self: *KotlinGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("/** ");
            try self.write(doc);
            try self.write(" */\n");
        }

        // Check for @alias attribute and add Jackson annotation
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.writeIndent();
            try self.write("@JsonProperty(\"");
            try self.write(alias_name.?);
            try self.write("\")\n");
        }

        try self.writeIndent();
        try self.write("val ");
        try self.write(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);
    }

    fn generateEnum(self: *KotlinGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("/**");
            try self.write("\n");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.write(" */");
            try self.write("\n");
        }

        // Write enum definition
        try self.write("enum class ");
        try self.write(enm.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Write enum values
        for (enm.values.items, 0..) |val, i| {
            try self.generateEnumValue(&val);
            if (i < enm.values.items.len - 1) {
                try self.write(",\n");
            } else {
                try self.write("\n");
            }
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *KotlinGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("/** ");
            try self.write(doc);
            try self.write(" */\n");
        }

        try self.writeIndent();
        try self.write(val.name);
    }

    fn generateFunction(self: *KotlinGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("/**");
            try self.write("\n");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.write(" */");
            try self.write("\n");
        }

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("/**");
            try self.writeLine(" * Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write(" * ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine(" */");
        }

        // Write function signature
        try self.write("fun ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write("): ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(" {");

        self.indent_level += 1;
        try self.writeLine("throw UnsupportedOperationException(\"This is a stub for LLM function\")");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *KotlinGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const kotlin_type = mapPrimitiveType(prim);
                try self.write(kotlin_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write("?");
            },
            .union_type => |union_ty| {
                // Kotlin doesn't have union types
                // Check if one type is null - if so, use nullable
                if (union_ty.types.items.len == 2) {
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.writeTypeAnnotation(non_null_type.?);
                        try self.write("?");
                    } else {
                        try self.write("Any?");
                    }
                } else {
                    try self.write("Any");
                }
            },
            .map => |map| {
                try self.write("Map<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                // Literals in Kotlin are just their types
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("Int"),
                    .float => try self.write("Double"),
                    .bool => try self.write("Boolean"),
                    .null_value => try self.write("Any?"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "Int",
            .float => "Double",
            .bool => "Boolean",
            .null_type => "Any?",
            .image => "ByteArray",    // Image type as byte array
            .audio => "ByteArray",    // Audio type as byte array
            .video => "ByteArray",    // Video type as byte array
            .pdf => "ByteArray",      // PDF type as byte array
        };
    }

    fn write(self: *KotlinGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *KotlinGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *KotlinGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Kotlin Generator Tests
test "KotlinGenerator: simple data class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = KotlinGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "data class Person(") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "val name: String") != null);
}

test "KotlinGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = KotlinGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "enum class Status {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active") != null);
}

test "KotlinGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = KotlinGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "val age: Int?") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "val tags: List<String>") != null);
}

test "KotlinGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = KotlinGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "val metadata: Map<String, String>") != null);
}

test "KotlinGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = KotlinGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "fun Greet(p: Person): String {") != null);
}

test "KotlinGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = KotlinGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "@JsonProperty(\"email_address\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "val email: String") != null);
}

/// PHP code generator (PHP 8.1+)
pub const PHPGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) PHPGenerator {
        return PHPGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate PHP code from AST
    pub fn generate(self: *PHPGenerator, tree: *const Ast) !void {
        // Write header
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *PHPGenerator) !void {
        try self.writeLine("<?php");
        try self.writeLine("");
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("declare(strict_types=1);");
        try self.writeLine("");
    }

    fn generateClass(self: *PHPGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write class definition
        try self.write("class ");
        try self.write(class.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate properties
        for (class.properties.items) |prop| {
            try self.generateProperty(&prop);
        }

        // Generate constructor if there are properties
        if (class.properties.items.len > 0) {
            try self.writeLine("");
            try self.generateConstructor(class);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateProperty(self: *PHPGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write property with type annotation
        try self.writeIndent();
        try self.write("public ");
        try self.writeTypeAnnotation(prop.type_expr);
        try self.write(" $");
        try self.write(prop.name);
        try self.write(";\n");
    }

    fn generateConstructor(self: *PHPGenerator, class: *const ClassDecl) !void {
        try self.writeLine("/**");
        try self.writeLine(" * Constructor");
        try self.writeLine(" */");
        try self.writeLine("public function __construct(");

        self.indent_level += 1;

        // Generate constructor parameters
        for (class.properties.items, 0..) |prop, i| {
            try self.writeIndent();
            try self.writeTypeAnnotation(prop.type_expr);
            try self.write(" $");
            try self.write(prop.name);

            if (i < class.properties.items.len - 1) {
                try self.write(",\n");
            } else {
                try self.write("\n");
            }
        }

        self.indent_level -= 1;
        try self.writeLine(") {");

        self.indent_level += 1;

        // Generate property assignments
        for (class.properties.items) |prop| {
            try self.writeIndent();
            try self.write("$this->");
            try self.write(prop.name);
            try self.write(" = $");
            try self.write(prop.name);
            try self.write(";\n");
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnum(self: *PHPGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write enum definition (PHP 8.1+ backed enum)
        try self.write("enum ");
        try self.write(enm.name);
        try self.writeLine(": string {");

        self.indent_level += 1;

        // Generate enum cases
        for (enm.values.items) |val| {
            try self.generateEnumValue(&val);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *PHPGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        try self.writeIndent();
        try self.write("case ");
        try self.write(val.name);
        try self.write(" = '");
        try self.write(val.name);
        try self.write("';\n");
    }

    fn generateFunction(self: *PHPGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");

            // Add parameter documentation
            for (func.parameters.items) |param| {
                try self.write(" * @param ");
                try self.writeTypeAnnotationDocstring(param.type_expr);
                try self.write(" $");
                try self.write(param.name);
                try self.write("\n");
            }

            // Add return documentation
            try self.write(" * @return ");
            try self.writeTypeAnnotationDocstring(func.return_type);
            try self.write("\n");

            // Add prompt as part of docstring if present
            if (func.prompt) |prompt| {
                try self.writeLine(" *");
                try self.writeLine(" * Prompt:");
                var lines = std.mem.splitSequence(u8, prompt, "\n");
                while (lines.next()) |line| {
                    try self.write(" * ");
                    try self.write(line);
                    try self.write("\n");
                }
            }

            try self.writeLine(" */");
        } else if (func.prompt) |prompt| {
            // No docstring but has prompt
            try self.writeLine("/**");
            try self.writeLine(" * Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write(" * ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine(" */");
        }

        // Write function signature
        try self.write("function ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.writeTypeAnnotation(param.type_expr);
            try self.write(" $");
            try self.write(param.name);
        }

        try self.write("): ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(" {");

        self.indent_level += 1;
        try self.writeLine("throw new \\Exception('This is a stub for LLM function');");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *PHPGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const php_type = mapPrimitiveType(prim);
                try self.write(php_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => {
                try self.write("array"); // PHP uses generic array type
            },
            .optional => |inner| {
                // PHP nullable types use ? prefix
                try self.write("?");
                try self.writeTypeAnnotation(inner);
            },
            .union_type => |union_ty| {
                // PHP 8.0+ union types
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write("|");
                    try self.writeTypeAnnotation(ty);
                }
            },
            .map => {
                try self.write("array"); // PHP uses array for maps
            },
            .literal => |lit| {
                // For literal types in unions, just write the base type
                switch (lit) {
                    .string => try self.write("string"),
                    .int => try self.write("int"),
                    .float => try self.write("float"),
                    .bool => try self.write("bool"),
                    .null_value => try self.write("null"),
                }
            },
        }
    }

    fn writeTypeAnnotationDocstring(self: *PHPGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const php_type = mapPrimitiveType(prim);
                try self.write(php_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.writeTypeAnnotationDocstring(inner);
                try self.write("[]");
            },
            .optional => |inner| {
                try self.writeTypeAnnotationDocstring(inner);
                try self.write("|null");
            },
            .union_type => |union_ty| {
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write("|");
                    try self.writeTypeAnnotationDocstring(ty);
                }
            },
            .map => |map| {
                try self.write("array<");
                try self.writeTypeAnnotationDocstring(map.key_type);
                try self.write(",");
                try self.writeTypeAnnotationDocstring(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => try self.write("string"),
                    .int => try self.write("int"),
                    .float => try self.write("float"),
                    .bool => try self.write("bool"),
                    .null_value => try self.write("null"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "string",
            .int => "int",
            .float => "float",
            .bool => "bool",
            .null_type => "null",
            .image => "string",  // Image as string (base64 or path)
            .audio => "string",  // Audio as string (base64 or path)
            .video => "string",  // Video as string (base64 or path)
            .pdf => "string",    // PDF as string (base64 or path)
        };
    }

    fn write(self: *PHPGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *PHPGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *PHPGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// PHP Generator Tests
test "PHPGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PHPGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Person {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public string $name;") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public function __construct(") != null);
}

test "PHPGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    const inactive = EnumValue{
        .name = "Inactive",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try enum_decl.values.append(allocator, inactive);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PHPGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "enum Status: string {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "case Active = 'Active';") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "case Inactive = 'Inactive';") != null);
}

test "PHPGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PHPGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public ?int $age;") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "public array $tags;") != null);
}

test "PHPGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PHPGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "public array $metadata;") != null);
}

test "PHPGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PHPGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "function Greet(Person $p): string {") != null);
}

test "PHPGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PHPGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Person|null") != null);
}

/// Scala code generator
pub const ScalaGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) ScalaGenerator {
        return ScalaGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Scala code from AST
    pub fn generate(self: *ScalaGenerator, tree: *const Ast) !void {
        // Write header
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateCaseClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *ScalaGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("package com.baml.generated");
        try self.writeLine("");
        try self.writeLine("import io.circe.{Decoder, Encoder}");
        try self.writeLine("import io.circe.generic.semiauto._");
        try self.writeLine("");
    }

    fn generateCaseClass(self: *ScalaGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeLine("/**");
            try self.write("  * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("  */");
        }

        // Write case class definition
        try self.write("case class ");
        try self.write(class.name);
        try self.write("(");

        if (class.properties.items.len > 0) {
            try self.write("\n");
            self.indent_level += 1;

            // Generate properties as constructor parameters
            for (class.properties.items, 0..) |prop, i| {
                try self.generateProperty(&prop, i == class.properties.items.len - 1);
            }

            self.indent_level -= 1;
            try self.writeLine(")");
        } else {
            try self.writeLine(")");
        }

        // Generate circe codecs
        try self.writeLine("");
        try self.write("object ");
        try self.write(class.name);
        try self.writeLine(" {");
        self.indent_level += 1;
        try self.write("implicit val decoder: Decoder[");
        try self.write(class.name);
        try self.write("] = deriveDecoder[");
        try self.write(class.name);
        try self.writeLine("]");
        try self.write("implicit val encoder: Encoder[");
        try self.write(class.name);
        try self.write("] = deriveEncoder[");
        try self.write(class.name);
        try self.writeLine("]");
        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateProperty(self: *ScalaGenerator, prop: *const Property, is_last: bool) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write("  * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeIndent();
            try self.writeLine("  */");
        }

        try self.writeIndent();

        // Check for @alias attribute
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        // Add JSON field annotation if alias exists
        if (has_alias and alias_name != null) {
            try self.write("@io.circe.generic.JsonKey(\"");
            try self.write(alias_name.?);
            try self.write("\") ");
        }

        try self.write(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        if (!is_last) {
            try self.write(",");
        }
        try self.write("\n");
    }

    fn generateEnum(self: *ScalaGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeLine("/**");
            try self.write("  * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("  */");
        }

        // Write sealed trait for enum
        try self.write("sealed trait ");
        try self.write(enm.name);
        try self.writeLine("");
        try self.writeLine("");

        // Write companion object with case objects
        try self.write("object ");
        try self.write(enm.name);
        try self.writeLine(" {");
        self.indent_level += 1;

        // Generate case objects for each enum value
        for (enm.values.items) |val| {
            try self.generateEnumValue(&val, enm.name);
        }

        // Generate list of all values
        try self.writeLine("");
        try self.write("val values: List[");
        try self.write(enm.name);
        try self.write("] = List(");
        for (enm.values.items, 0..) |val, i| {
            if (i > 0) try self.write(", ");
            try self.write(val.name);
        }
        try self.writeLine(")");

        // Generate circe codecs
        try self.writeLine("");
        try self.write("implicit val decoder: Decoder[");
        try self.write(enm.name);
        try self.write("] = Decoder.decodeString.emap {");
        try self.writeLine("");
        self.indent_level += 1;
        for (enm.values.items) |val| {
            try self.writeIndent();
            try self.write("case \"");
            try self.write(val.name);
            try self.write("\" => Right(");
            try self.write(val.name);
            try self.writeLine(")");
        }
        try self.writeIndent();
        try self.writeLine("case other => Left(s\"Invalid enum value: $other\")");
        self.indent_level -= 1;
        try self.writeLine("}");

        try self.writeLine("");
        try self.write("implicit val encoder: Encoder[");
        try self.write(enm.name);
        try self.write("] = Encoder.encodeString.contramap[");
        try self.write(enm.name);
        try self.write("] {");
        try self.writeLine("");
        self.indent_level += 1;
        for (enm.values.items) |val| {
            try self.writeIndent();
            try self.write("case ");
            try self.write(val.name);
            try self.write(" => \"");
            try self.write(val.name);
            try self.writeLine("\"");
        }
        self.indent_level -= 1;
        try self.writeLine("}");

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *ScalaGenerator, val: *const EnumValue, enum_name: []const u8) !void {
        _ = enum_name;

        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write("  * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeIndent();
            try self.writeLine("  */");
        }

        try self.writeIndent();
        try self.write("case object ");
        try self.write(val.name);
        try self.writeLine("");
    }

    fn generateFunction(self: *ScalaGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeLine("/**");
            try self.write("  * ");
            try self.write(doc);
            try self.write("\n");

            // Add parameter documentation
            for (func.parameters.items) |param| {
                try self.write("  * @param ");
                try self.write(param.name);
                try self.write(" ");
                try self.writeTypeAnnotationDocstring(param.type_expr);
                try self.write("\n");
            }

            // Add return documentation
            try self.write("  * @return ");
            try self.writeTypeAnnotationDocstring(func.return_type);
            try self.write("\n");

            // Add prompt as part of docstring if present
            if (func.prompt) |prompt| {
                try self.writeLine("  *");
                try self.writeLine("  * Prompt:");
                var lines = std.mem.splitSequence(u8, prompt, "\n");
                while (lines.next()) |line| {
                    try self.write("  * ");
                    try self.write(line);
                    try self.write("\n");
                }
            }

            try self.writeLine("  */");
        } else if (func.prompt) |prompt| {
            // No docstring but has prompt
            try self.writeLine("/**");
            try self.writeLine("  * Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("  * ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine("  */");
        }

        // Write function signature
        try self.write("def ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write("): ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(" = {");

        self.indent_level += 1;
        try self.writeLine("throw new UnsupportedOperationException(\"This is a stub for LLM function\")");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *ScalaGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const scala_type = mapPrimitiveType(prim);
                try self.write(scala_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .optional => |inner| {
                try self.write("Option[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .union_type => |union_ty| {
                // Scala uses Either for unions, or Option for nullable
                if (union_ty.types.items.len == 2) {
                    // Check if one type is null - if so, use Option
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.write("Option[");
                        try self.writeTypeAnnotation(non_null_type.?);
                        try self.write("]");
                    } else {
                        try self.write("Option[Any]");
                    }
                } else {
                    // For complex unions, use Either or Any
                    try self.write("Any");
                }
            },
            .map => |map| {
                try self.write("Map[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("]");
            },
            .literal => |lit| {
                // For literal types, just use the base type
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("Int"),
                    .float => try self.write("Double"),
                    .bool => try self.write("Boolean"),
                    .null_value => try self.write("Option[Nothing]"),
                }
            },
        }
    }

    fn writeTypeAnnotationDocstring(self: *ScalaGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const scala_type = mapPrimitiveType(prim);
                try self.write(scala_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List[");
                try self.writeTypeAnnotationDocstring(inner);
                try self.write("]");
            },
            .optional => |inner| {
                try self.write("Option[");
                try self.writeTypeAnnotationDocstring(inner);
                try self.write("]");
            },
            .union_type => |union_ty| {
                if (union_ty.types.items.len == 2) {
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.write("Option[");
                        try self.writeTypeAnnotationDocstring(non_null_type.?);
                        try self.write("]");
                    } else {
                        try self.write("Option[Any]");
                    }
                } else {
                    try self.write("Any");
                }
            },
            .map => |map| {
                try self.write("Map[");
                try self.writeTypeAnnotationDocstring(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotationDocstring(map.value_type);
                try self.write("]");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("Int"),
                    .float => try self.write("Double"),
                    .bool => try self.write("Boolean"),
                    .null_value => try self.write("Option[Nothing]"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "Int",
            .float => "Double",
            .bool => "Boolean",
            .null_type => "Option[Nothing]",
            .image => "Array[Byte]",  // Image as byte array
            .audio => "Array[Byte]",  // Audio as byte array
            .video => "Array[Byte]",  // Video as byte array
            .pdf => "Array[Byte]",    // PDF as byte array
        };
    }

    fn write(self: *ScalaGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *ScalaGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *ScalaGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// Scala Generator Tests
test "ScalaGenerator: simple case class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ScalaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "case class Person(") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: String") != null);
}

test "ScalaGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ScalaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "sealed trait Status") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "case object Active") != null);
}

test "ScalaGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ScalaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: Option[Int]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: List[String]") != null);
}

test "ScalaGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ScalaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Map[String, String]") != null);
}

test "ScalaGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ScalaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "def Greet(p: Person): String") != null);
}

test "ScalaGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = ScalaGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "@io.circe.generic.JsonKey(\"email_address\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "email: String") != null);
}
