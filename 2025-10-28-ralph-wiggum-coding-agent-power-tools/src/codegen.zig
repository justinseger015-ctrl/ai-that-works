const std = @import("std");
const ast = @import("ast.zig");
const Ast = ast.Ast;
const Declaration = ast.Declaration;
const ClassDecl = ast.ClassDecl;
const EnumDecl = ast.EnumDecl;
const FunctionDecl = ast.FunctionDecl;
const TypeExpr = ast.TypeExpr;
const Property = ast.Property;
const EnumValue = ast.EnumValue;
const Parameter = ast.Parameter;
const PrimitiveType = ast.PrimitiveType;

/// Helper function to check if a declaration has @@dynamic attribute
fn hasDynamicAttribute(attributes: *const std.ArrayList(ast.Attribute)) bool {
    for (attributes.items) |attr| {
        if (attr.is_class_level and std.mem.eql(u8, attr.name, "dynamic")) {
            return true;
        }
    }
    return false;
}

/// Python code generator
pub const PythonGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) PythonGenerator {
        return PythonGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Python code from AST
    pub fn generate(self: *PythonGenerator, tree: *const Ast) !void {
        // Write header with imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    /// Generate Python TypeBuilder module
    pub fn generateTypeBuilder(self: *PythonGenerator, tree: *const Ast) !void {
        // Write header
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("# TypeBuilder for dynamic types");
        try self.writeLine("");
        try self.writeLine("from typing import Optional, Any, Dict, List");
        try self.writeLine("");

        // Count dynamic types
        var has_dynamic_class = false;
        var has_dynamic_enum = false;
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| {
                    if (hasDynamicAttribute(&class.attributes)) {
                        has_dynamic_class = true;
                    }
                },
                .enum_decl => |enm| {
                    if (hasDynamicAttribute(&enm.attributes)) {
                        has_dynamic_enum = true;
                    }
                },
                else => {},
            }
        }

        // If no dynamic types, just create an empty TypeBuilder
        if (!has_dynamic_class and !has_dynamic_enum) {
            try self.writeLine("class TypeBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"TypeBuilder for runtime type modifications (no dynamic types defined)\"\"\"");
            try self.writeLine("pass");
            self.indent_level -= 1;
            return;
        }

        // Generate helper classes for dynamic types
        if (has_dynamic_class) {
            try self.writeLine("class DynamicClassBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Helper for building dynamic class properties at runtime\"\"\"");
            try self.writeLine("");
            try self.writeLine("def __init__(self, class_name: str):");
            self.indent_level += 1;
            try self.writeLine("self.class_name = class_name");
            try self.writeLine("self.properties: Dict[str, Any] = {}");
            self.indent_level -= 1;
            try self.writeLine("");
            try self.writeLine("def add_property(self, name: str, type_expr: Any, description: Optional[str] = None):");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Add a property to this dynamic class\"\"\"");
            try self.writeLine("self.properties[name] = {");
            self.indent_level += 1;
            try self.writeLine("'type': type_expr,");
            try self.writeLine("'description': description");
            self.indent_level -= 1;
            try self.writeLine("}");
            try self.writeLine("return self");
            self.indent_level -= 1;
            self.indent_level -= 1;
            try self.writeLine("");
        }

        if (has_dynamic_enum) {
            try self.writeLine("class DynamicEnumBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Helper for building dynamic enum values at runtime\"\"\"");
            try self.writeLine("");
            try self.writeLine("def __init__(self, enum_name: str):");
            self.indent_level += 1;
            try self.writeLine("self.enum_name = enum_name");
            try self.writeLine("self.values: List[str] = []");
            self.indent_level -= 1;
            try self.writeLine("");
            try self.writeLine("def add_value(self, value: str):");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Add a value to this dynamic enum\"\"\"");
            try self.writeLine("self.values.append(value)");
            try self.writeLine("return self");
            self.indent_level -= 1;
            self.indent_level -= 1;
            try self.writeLine("");
        }

        // Generate TypeBuilder class
        try self.writeLine("class TypeBuilder:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"TypeBuilder for runtime type modifications\"\"\"");
        try self.writeLine("");
        try self.writeLine("def __init__(self):");
        self.indent_level += 1;

        // Initialize dynamic class builders
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| {
                    if (hasDynamicAttribute(&class.attributes)) {
                        try self.writeIndent();
                        try self.write("self.");
                        try self.write(class.name);
                        try self.write(" = DynamicClassBuilder(\"");
                        try self.write(class.name);
                        try self.write("\")\n");
                    }
                },
                .enum_decl => |enm| {
                    if (hasDynamicAttribute(&enm.attributes)) {
                        try self.writeIndent();
                        try self.write("self.");
                        try self.write(enm.name);
                        try self.write(" = DynamicEnumBuilder(\"");
                        try self.write(enm.name);
                        try self.write("\")\n");
                    }
                },
                else => {},
            }
        }

        self.indent_level -= 1;
        try self.writeLine("");

        // Add type helper methods
        try self.writeLine("def string(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return string type\"\"\"");
        try self.writeLine("return 'string'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def int(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return int type\"\"\"");
        try self.writeLine("return 'int'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def float(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return float type\"\"\"");
        try self.writeLine("return 'float'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def bool(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return bool type\"\"\"");
        try self.writeLine("return 'bool'");
        self.indent_level -= 1;

        self.indent_level -= 1;
        try self.writeLine("");
    }

    fn writeHeader(self: *PythonGenerator) !void {
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("from typing import Optional, Union, List, Dict, Any");
        try self.writeLine("from pydantic import BaseModel, Field");
        try self.writeLine("from enum import Enum");
        try self.writeLine("");
    }

    fn generateClass(self: *PythonGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write class definition
        try self.write("class ");
        try self.write(class.name);
        try self.writeLine("(BaseModel):");

        self.indent_level += 1;

        // Handle empty class
        if (class.properties.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate properties
            for (class.properties.items) |prop| {
                try self.generateProperty(&prop);
            }
        }

        self.indent_level -= 1;
    }

    fn generateProperty(self: *PythonGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        // Write property name with indentation
        try self.writeIndent();
        try self.write(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        // Check for @alias attribute and add Field with alias
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.write(" = Field(alias=\"");
            try self.write(alias_name.?);
            try self.write("\")");
        }

        try self.write("\n");
    }

    fn generateEnum(self: *PythonGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write enum definition
        try self.write("class ");
        try self.write(enm.name);
        try self.writeLine("(str, Enum):");

        self.indent_level += 1;

        // Handle empty enum
        if (enm.values.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate enum values
            for (enm.values.items) |val| {
                try self.generateEnumValue(&val);
            }
        }

        self.indent_level -= 1;
    }

    fn generateEnumValue(self: *PythonGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"\n");
    }

    fn generateFunction(self: *PythonGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write function signature
        try self.write("def ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") -> ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(":");

        self.indent_level += 1;

        // Write function body (stub)
        if (func.prompt) |prompt| {
            try self.writeLine("\"\"\"");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.writeIndent();
                try self.buffer.appendSlice(self.allocator, line);
                try self.buffer.append(self.allocator, '\n');
            }
            try self.writeLine("\"\"\"");
        }

        try self.writeLine("raise NotImplementedError(\"This is a stub for LLM function\")");

        self.indent_level -= 1;
    }

    fn writeTypeAnnotation(self: *PythonGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const python_type = mapPrimitiveType(prim);
                try self.write(python_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .optional => |inner| {
                try self.write("Optional[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .union_type => |union_ty| {
                try self.write("Union[");
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeTypeAnnotation(ty);
                }
                try self.write("]");
            },
            .map => |map| {
                try self.write("Dict[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("]");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => |s| {
                        try self.write("\"");
                        try self.write(s);
                        try self.write("\"");
                    },
                    .int => |i| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{i});
                        try self.write(str);
                    },
                    .float => |f| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{f});
                        try self.write(str);
                    },
                    .bool => |b| {
                        try self.write(if (b) "True" else "False");
                    },
                    .null_value => {
                        try self.write("None");
                    },
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "str",
            .int => "int",
            .float => "float",
            .bool => "bool",
            .null_type => "None",
            .image => "Any",  // Image type as Any for now
            .audio => "Any",  // Audio type as Any for now
            .video => "Any",  // Video type as Any for now
            .pdf => "Any",    // PDF type as Any for now
        };
    }

    fn write(self: *PythonGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *PythonGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *PythonGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Tests
test "PythonGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Person(BaseModel):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: str") != null);
}

test "PythonGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Status(str, Enum):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = \"Active\"") != null);
}

test "PythonGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: Optional[int]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: List[str]") != null);
}

test "PythonGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Dict[str, str]") != null);
}

test "PythonGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Union[Person, None]") != null);
}

test "PythonGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "def Greet(p: Person) -> str:") != null);
}

test "PythonGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "email: str = Field(alias=\"email_address\")") != null);
}

/// TypeScript code generator
pub const TypeScriptGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) TypeScriptGenerator {
        return TypeScriptGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate TypeScript code from AST
    pub fn generate(self: *TypeScriptGenerator, tree: *const Ast) !void {
        // Write header with comments
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateInterface(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *TypeScriptGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
    }

    fn generateInterface(self: *TypeScriptGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write interface definition
        try self.write("export interface ");
        try self.write(class.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate properties
        for (class.properties.items) |prop| {
            try self.generateProperty(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateProperty(self: *TypeScriptGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write property name with indentation
        try self.writeIndent();

        // Check for @alias attribute
        var property_name = prop.name;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    property_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        try self.write(property_name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write(";\n");
    }

    fn generateEnum(self: *TypeScriptGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write enum definition
        try self.write("export enum ");
        try self.write(enm.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate enum values
        for (enm.values.items, 0..) |val, i| {
            try self.generateEnumValue(&val, i == enm.values.items.len - 1);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *TypeScriptGenerator, val: *const EnumValue, is_last: bool) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"");
        if (!is_last) {
            try self.write(",");
        }
        try self.write("\n");
    }

    fn generateFunction(self: *TypeScriptGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");

            // Add prompt as part of docstring if present
            if (func.prompt) |prompt| {
                try self.writeLine(" *");
                try self.writeLine(" * Prompt:");
                var lines = std.mem.splitSequence(u8, prompt, "\n");
                while (lines.next()) |line| {
                    try self.write(" * ");
                    try self.write(line);
                    try self.write("\n");
                }
            }

            try self.writeLine(" */");
        } else if (func.prompt) |prompt| {
            // No docstring but has prompt
            try self.writeLine("/**");
            try self.writeLine(" * Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write(" * ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine(" */");
        }

        // Write function signature
        try self.write("export function ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write("): ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(" {");

        self.indent_level += 1;
        try self.writeLine("throw new Error('This is a stub for LLM function');");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *TypeScriptGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const ts_type = mapPrimitiveType(prim);
                try self.write(ts_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write("[]");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write(" | undefined");
            },
            .union_type => |union_ty| {
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(" | ");
                    try self.writeTypeAnnotation(ty);
                }
            },
            .map => |map| {
                try self.write("Record<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => |s| {
                        try self.write("\"");
                        try self.write(s);
                        try self.write("\"");
                    },
                    .int => |i| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{i});
                        try self.write(str);
                    },
                    .float => |f| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{f});
                        try self.write(str);
                    },
                    .bool => |b| {
                        try self.write(if (b) "true" else "false");
                    },
                    .null_value => {
                        try self.write("null");
                    },
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "string",
            .int => "number",
            .float => "number",
            .bool => "boolean",
            .null_type => "null",
            .image => "any",  // Image type as any for now
            .audio => "any",  // Audio type as any for now
            .video => "any",  // Video type as any for now
            .pdf => "any",    // PDF type as any for now
        };
    }

    fn write(self: *TypeScriptGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *TypeScriptGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *TypeScriptGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// TypeScript Generator Tests
test "TypeScriptGenerator: simple interface" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export interface Person {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: string;") != null);
}

test "TypeScriptGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export enum Status {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = \"Active\"") != null);
}

test "TypeScriptGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: number | undefined;") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: string[];") != null);
}

test "TypeScriptGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Record<string, string>;") != null);
}

test "TypeScriptGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Person | null") != null);
}

test "TypeScriptGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export function Greet(p: Person): string {") != null);
}

test "TypeScriptGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "email_address: string;") != null);
}

// TypeBuilder Tests
test "PythonGenerator: TypeBuilder with no dynamic types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a simple class without @@dynamic
    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "no dynamic types defined") != null);
}

test "PythonGenerator: TypeBuilder with dynamic class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a class with @@dynamic
    var class_decl = ClassDecl.init(allocator, "User", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.attributes.append(allocator, attr);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicClassBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.User = DynamicClassBuilder(\"User\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def add_property") != null);
}

test "PythonGenerator: TypeBuilder with dynamic enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create an enum with @@dynamic
    var enum_decl = EnumDecl.init(allocator, "Category", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 3, .column = 3 },
    };
    try enum_decl.attributes.append(allocator, attr);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicEnumBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.Category = DynamicEnumBuilder(\"Category\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def add_value") != null);
}

test "PythonGenerator: TypeBuilder with multiple dynamic types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a dynamic class
    var class_decl = ClassDecl.init(allocator, "User", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    const class_attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.attributes.append(allocator, class_attr);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    // Create a dynamic enum
    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 5, .column = 1 });
    defer enum_decl.deinit(allocator);

    const enum_attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 6, .column = 3 },
    };
    try enum_decl.attributes.append(allocator, enum_attr);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicClassBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicEnumBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.User = DynamicClassBuilder(\"User\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.Status = DynamicEnumBuilder(\"Status\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def string(self)") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def int(self)") != null);
}

test "hasDynamicAttribute: detects @@dynamic" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer {
        for (attributes.items) |*attr| {
            attr.deinit(allocator);
        }
        attributes.deinit(allocator);
    }

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 1, .column = 1 },
    };
    try attributes.append(allocator, attr);

    try std.testing.expect(hasDynamicAttribute(&attributes) == true);
}

test "hasDynamicAttribute: ignores @dynamic (not class level)" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer {
        for (attributes.items) |*attr| {
            attr.deinit(allocator);
        }
        attributes.deinit(allocator);
    }

    // Add @dynamic attribute (not @@)
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = false, // Not class-level
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 1, .column = 1 },
    };
    try attributes.append(allocator, attr);

    try std.testing.expect(hasDynamicAttribute(&attributes) == false);
}

test "hasDynamicAttribute: returns false for no attributes" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer attributes.deinit(allocator);

    try std.testing.expect(hasDynamicAttribute(&attributes) == false);
}
