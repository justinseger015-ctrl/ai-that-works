const std = @import("std");
const ast = @import("ast.zig");
const Ast = ast.Ast;
const Declaration = ast.Declaration;
const ClassDecl = ast.ClassDecl;
const EnumDecl = ast.EnumDecl;
const FunctionDecl = ast.FunctionDecl;
const TypeExpr = ast.TypeExpr;
const Property = ast.Property;
const EnumValue = ast.EnumValue;
const Parameter = ast.Parameter;
const PrimitiveType = ast.PrimitiveType;

/// Helper function to check if a declaration has @@dynamic attribute
fn hasDynamicAttribute(attributes: *const std.ArrayList(ast.Attribute)) bool {
    for (attributes.items) |attr| {
        if (attr.is_class_level and std.mem.eql(u8, attr.name, "dynamic")) {
            return true;
        }
    }
    return false;
}

/// Python code generator
pub const PythonGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) PythonGenerator {
        return PythonGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Python code from AST
    pub fn generate(self: *PythonGenerator, tree: *const Ast) !void {
        // Write header with imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    /// Generate Python TypeBuilder module
    pub fn generateTypeBuilder(self: *PythonGenerator, tree: *const Ast) !void {
        // Write header
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("# TypeBuilder for dynamic types");
        try self.writeLine("");
        try self.writeLine("from typing import Optional, Any, Dict, List");
        try self.writeLine("");

        // Count dynamic types
        var has_dynamic_class = false;
        var has_dynamic_enum = false;
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| {
                    if (hasDynamicAttribute(&class.attributes)) {
                        has_dynamic_class = true;
                    }
                },
                .enum_decl => |enm| {
                    if (hasDynamicAttribute(&enm.attributes)) {
                        has_dynamic_enum = true;
                    }
                },
                else => {},
            }
        }

        // If no dynamic types, just create an empty TypeBuilder
        if (!has_dynamic_class and !has_dynamic_enum) {
            try self.writeLine("class TypeBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"TypeBuilder for runtime type modifications (no dynamic types defined)\"\"\"");
            try self.writeLine("pass");
            self.indent_level -= 1;
            return;
        }

        // Generate helper classes for dynamic types
        if (has_dynamic_class) {
            try self.writeLine("class DynamicClassBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Helper for building dynamic class properties at runtime\"\"\"");
            try self.writeLine("");
            try self.writeLine("def __init__(self, class_name: str):");
            self.indent_level += 1;
            try self.writeLine("self.class_name = class_name");
            try self.writeLine("self.properties: Dict[str, Any] = {}");
            self.indent_level -= 1;
            try self.writeLine("");
            try self.writeLine("def add_property(self, name: str, type_expr: Any, description: Optional[str] = None):");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Add a property to this dynamic class\"\"\"");
            try self.writeLine("self.properties[name] = {");
            self.indent_level += 1;
            try self.writeLine("'type': type_expr,");
            try self.writeLine("'description': description");
            self.indent_level -= 1;
            try self.writeLine("}");
            try self.writeLine("return self");
            self.indent_level -= 1;
            self.indent_level -= 1;
            try self.writeLine("");
        }

        if (has_dynamic_enum) {
            try self.writeLine("class DynamicEnumBuilder:");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Helper for building dynamic enum values at runtime\"\"\"");
            try self.writeLine("");
            try self.writeLine("def __init__(self, enum_name: str):");
            self.indent_level += 1;
            try self.writeLine("self.enum_name = enum_name");
            try self.writeLine("self.values: List[str] = []");
            self.indent_level -= 1;
            try self.writeLine("");
            try self.writeLine("def add_value(self, value: str):");
            self.indent_level += 1;
            try self.writeLine("\"\"\"Add a value to this dynamic enum\"\"\"");
            try self.writeLine("self.values.append(value)");
            try self.writeLine("return self");
            self.indent_level -= 1;
            self.indent_level -= 1;
            try self.writeLine("");
        }

        // Generate TypeBuilder class
        try self.writeLine("class TypeBuilder:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"TypeBuilder for runtime type modifications\"\"\"");
        try self.writeLine("");
        try self.writeLine("def __init__(self):");
        self.indent_level += 1;

        // Initialize dynamic class builders
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| {
                    if (hasDynamicAttribute(&class.attributes)) {
                        try self.writeIndent();
                        try self.write("self.");
                        try self.write(class.name);
                        try self.write(" = DynamicClassBuilder(\"");
                        try self.write(class.name);
                        try self.write("\")\n");
                    }
                },
                .enum_decl => |enm| {
                    if (hasDynamicAttribute(&enm.attributes)) {
                        try self.writeIndent();
                        try self.write("self.");
                        try self.write(enm.name);
                        try self.write(" = DynamicEnumBuilder(\"");
                        try self.write(enm.name);
                        try self.write("\")\n");
                    }
                },
                else => {},
            }
        }

        self.indent_level -= 1;
        try self.writeLine("");

        // Add type helper methods
        try self.writeLine("def string(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return string type\"\"\"");
        try self.writeLine("return 'string'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def int(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return int type\"\"\"");
        try self.writeLine("return 'int'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def float(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return float type\"\"\"");
        try self.writeLine("return 'float'");
        self.indent_level -= 1;
        try self.writeLine("");

        try self.writeLine("def bool(self) -> str:");
        self.indent_level += 1;
        try self.writeLine("\"\"\"Return bool type\"\"\"");
        try self.writeLine("return 'bool'");
        self.indent_level -= 1;

        self.indent_level -= 1;
        try self.writeLine("");
    }

    fn writeHeader(self: *PythonGenerator) !void {
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("from typing import Optional, Union, List, Dict, Any");
        try self.writeLine("from pydantic import BaseModel, Field");
        try self.writeLine("from enum import Enum");
        try self.writeLine("");
    }

    fn generateClass(self: *PythonGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write class definition
        try self.write("class ");
        try self.write(class.name);
        try self.writeLine("(BaseModel):");

        self.indent_level += 1;

        // Handle empty class
        if (class.properties.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate properties
            for (class.properties.items) |prop| {
                try self.generateProperty(&prop);
            }
        }

        self.indent_level -= 1;
    }

    fn generateProperty(self: *PythonGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        // Write property name with indentation
        try self.writeIndent();
        try self.write(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        // Check for @alias attribute and add Field with alias
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.write(" = Field(alias=\"");
            try self.write(alias_name.?);
            try self.write("\")");
        }

        try self.write("\n");
    }

    fn generateEnum(self: *PythonGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write enum definition
        try self.write("class ");
        try self.write(enm.name);
        try self.writeLine("(str, Enum):");

        self.indent_level += 1;

        // Handle empty enum
        if (enm.values.items.len == 0) {
            try self.writeLine("pass");
        } else {
            // Generate enum values
            for (enm.values.items) |val| {
                try self.generateEnumValue(&val);
            }
        }

        self.indent_level -= 1;
    }

    fn generateEnumValue(self: *PythonGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("\"\"\"");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
            try self.writeLine("\"\"\"");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"\n");
    }

    fn generateFunction(self: *PythonGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("\"\"\"");
            try self.write(doc);
            try self.writeLine("\"\"\"");
        }

        // Write function signature
        try self.write("def ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") -> ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(":");

        self.indent_level += 1;

        // Write function body (stub)
        if (func.prompt) |prompt| {
            try self.writeLine("\"\"\"");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.writeIndent();
                try self.buffer.appendSlice(self.allocator, line);
                try self.buffer.append(self.allocator, '\n');
            }
            try self.writeLine("\"\"\"");
        }

        try self.writeLine("raise NotImplementedError(\"This is a stub for LLM function\")");

        self.indent_level -= 1;
    }

    fn writeTypeAnnotation(self: *PythonGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const python_type = mapPrimitiveType(prim);
                try self.write(python_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("List[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .optional => |inner| {
                try self.write("Optional[");
                try self.writeTypeAnnotation(inner);
                try self.write("]");
            },
            .union_type => |union_ty| {
                try self.write("Union[");
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeTypeAnnotation(ty);
                }
                try self.write("]");
            },
            .map => |map| {
                try self.write("Dict[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("]");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => |s| {
                        try self.write("\"");
                        try self.write(s);
                        try self.write("\"");
                    },
                    .int => |i| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{i});
                        try self.write(str);
                    },
                    .float => |f| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{f});
                        try self.write(str);
                    },
                    .bool => |b| {
                        try self.write(if (b) "True" else "False");
                    },
                    .null_value => {
                        try self.write("None");
                    },
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "str",
            .int => "int",
            .float => "float",
            .bool => "bool",
            .null_type => "None",
            .image => "Any",  // Image type as Any for now
            .audio => "Any",  // Audio type as Any for now
            .video => "Any",  // Video type as Any for now
            .pdf => "Any",    // PDF type as Any for now
        };
    }

    fn write(self: *PythonGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *PythonGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *PythonGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Tests
test "PythonGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Person(BaseModel):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: str") != null);
}

test "PythonGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Status(str, Enum):") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = \"Active\"") != null);
}

test "PythonGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: Optional[int]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: List[str]") != null);
}

test "PythonGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Dict[str, str]") != null);
}

test "PythonGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Union[Person, None]") != null);
}

test "PythonGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "def Greet(p: Person) -> str:") != null);
}

test "PythonGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "email: str = Field(alias=\"email_address\")") != null);
}

/// TypeScript code generator
pub const TypeScriptGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) TypeScriptGenerator {
        return TypeScriptGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate TypeScript code from AST
    pub fn generate(self: *TypeScriptGenerator, tree: *const Ast) !void {
        // Write header with comments
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateInterface(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *TypeScriptGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
    }

    fn generateInterface(self: *TypeScriptGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write interface definition
        try self.write("export interface ");
        try self.write(class.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate properties
        for (class.properties.items) |prop| {
            try self.generateProperty(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateProperty(self: *TypeScriptGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write property name with indentation
        try self.writeIndent();

        // Check for @alias attribute
        var property_name = prop.name;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    property_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        try self.write(property_name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write(";\n");
    }

    fn generateEnum(self: *TypeScriptGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        // Write enum definition
        try self.write("export enum ");
        try self.write(enm.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate enum values
        for (enm.values.items, 0..) |val, i| {
            try self.generateEnumValue(&val, i == enm.values.items.len - 1);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *TypeScriptGenerator, val: *const EnumValue, is_last: bool) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeLine("/**");
            try self.writeIndent();
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");
            try self.writeLine(" */");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"");
        if (!is_last) {
            try self.write(",");
        }
        try self.write("\n");
    }

    fn generateFunction(self: *TypeScriptGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeLine("/**");
            try self.write(" * ");
            try self.write(doc);
            try self.write("\n");

            // Add prompt as part of docstring if present
            if (func.prompt) |prompt| {
                try self.writeLine(" *");
                try self.writeLine(" * Prompt:");
                var lines = std.mem.splitSequence(u8, prompt, "\n");
                while (lines.next()) |line| {
                    try self.write(" * ");
                    try self.write(line);
                    try self.write("\n");
                }
            }

            try self.writeLine(" */");
        } else if (func.prompt) |prompt| {
            // No docstring but has prompt
            try self.writeLine("/**");
            try self.writeLine(" * Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write(" * ");
                try self.write(line);
                try self.write("\n");
            }
            try self.writeLine(" */");
        }

        // Write function signature
        try self.write("export function ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write("): ");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(" {");

        self.indent_level += 1;
        try self.writeLine("throw new Error('This is a stub for LLM function');");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *TypeScriptGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const ts_type = mapPrimitiveType(prim);
                try self.write(ts_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write("[]");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write(" | undefined");
            },
            .union_type => |union_ty| {
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(" | ");
                    try self.writeTypeAnnotation(ty);
                }
            },
            .map => |map| {
                try self.write("Record<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => |s| {
                        try self.write("\"");
                        try self.write(s);
                        try self.write("\"");
                    },
                    .int => |i| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{i});
                        try self.write(str);
                    },
                    .float => |f| {
                        var buf: [32]u8 = undefined;
                        const str = try std.fmt.bufPrint(&buf, "{d}", .{f});
                        try self.write(str);
                    },
                    .bool => |b| {
                        try self.write(if (b) "true" else "false");
                    },
                    .null_value => {
                        try self.write("null");
                    },
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "string",
            .int => "number",
            .float => "number",
            .bool => "boolean",
            .null_type => "null",
            .image => "any",  // Image type as any for now
            .audio => "any",  // Audio type as any for now
            .video => "any",  // Video type as any for now
            .pdf => "any",    // PDF type as any for now
        };
    }

    fn write(self: *TypeScriptGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *TypeScriptGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *TypeScriptGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// TypeScript Generator Tests
test "TypeScriptGenerator: simple interface" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export interface Person {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "name: string;") != null);
}

test "TypeScriptGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export enum Status {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = \"Active\"") != null);
}

test "TypeScriptGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "age: number | undefined;") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "tags: string[];") != null);
}

test "TypeScriptGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "metadata: Record<string, string>;") != null);
}

test "TypeScriptGenerator: union types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Extract", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Return type: Person | null
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const null_type = try allocator.create(TypeExpr);
    null_type.* = .{ .primitive = .null_type };

    var types = std.ArrayList(*TypeExpr).init(allocator);
    try types.append(allocator, person_type);
    try types.append(allocator, null_type);

    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .union_type = .{ .types = types } };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Person | null") != null);
}

test "TypeScriptGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "export function Greet(p: Person): string {") != null);
}

test "TypeScriptGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = TypeScriptGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "email_address: string;") != null);
}

// TypeBuilder Tests
test "PythonGenerator: TypeBuilder with no dynamic types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a simple class without @@dynamic
    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "no dynamic types defined") != null);
}

test "PythonGenerator: TypeBuilder with dynamic class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a class with @@dynamic
    var class_decl = ClassDecl.init(allocator, "User", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.attributes.append(allocator, attr);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicClassBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.User = DynamicClassBuilder(\"User\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def add_property") != null);
}

test "PythonGenerator: TypeBuilder with dynamic enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create an enum with @@dynamic
    var enum_decl = EnumDecl.init(allocator, "Category", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 3, .column = 3 },
    };
    try enum_decl.attributes.append(allocator, attr);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicEnumBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class TypeBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.Category = DynamicEnumBuilder(\"Category\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def add_value") != null);
}

test "PythonGenerator: TypeBuilder with multiple dynamic types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    // Create a dynamic class
    var class_decl = ClassDecl.init(allocator, "User", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    const class_attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.attributes.append(allocator, class_attr);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    // Create a dynamic enum
    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 5, .column = 1 });
    defer enum_decl.deinit(allocator);

    const enum_attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 6, .column = 3 },
    };
    try enum_decl.attributes.append(allocator, enum_attr);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = PythonGenerator.init(allocator, &buffer);
    try gen.generateTypeBuilder(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicClassBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "class DynamicEnumBuilder:") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.User = DynamicClassBuilder(\"User\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "self.Status = DynamicEnumBuilder(\"Status\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def string(self)") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def int(self)") != null);
}

test "hasDynamicAttribute: detects @@dynamic" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer {
        for (attributes.items) |*attr| {
            attr.deinit(allocator);
        }
        attributes.deinit(allocator);
    }

    // Add @@dynamic attribute
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = true,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 1, .column = 1 },
    };
    try attributes.append(allocator, attr);

    try std.testing.expect(hasDynamicAttribute(&attributes) == true);
}

test "hasDynamicAttribute: ignores @dynamic (not class level)" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer {
        for (attributes.items) |*attr| {
            attr.deinit(allocator);
        }
        attributes.deinit(allocator);
    }

    // Add @dynamic attribute (not @@)
    const attr = ast.Attribute{
        .name = "dynamic",
        .is_class_level = false, // Not class-level
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 1, .column = 1 },
    };
    try attributes.append(allocator, attr);

    try std.testing.expect(hasDynamicAttribute(&attributes) == false);
}

test "hasDynamicAttribute: returns false for no attributes" {
    const allocator = std.testing.allocator;

    var attributes = std.ArrayList(ast.Attribute){};
    defer attributes.deinit(allocator);

    try std.testing.expect(hasDynamicAttribute(&attributes) == false);
}

/// Go code generator
pub const GoGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) GoGenerator {
        return GoGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Go code from AST
    pub fn generate(self: *GoGenerator, tree: *const Ast) !void {
        // Write header with package and imports
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateStruct(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *GoGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("package baml");
        try self.writeLine("");
        try self.writeLine("import (");
        self.indent_level += 1;
        try self.writeLine("\"errors\"");
        self.indent_level -= 1;
        try self.writeLine(")");
        try self.writeLine("");
    }

    fn generateStruct(self: *GoGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write struct definition
        try self.write("type ");
        try self.write(class.name);
        try self.writeLine(" struct {");

        self.indent_level += 1;

        // Generate fields
        for (class.properties.items) |prop| {
            try self.generateField(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateField(self: *GoGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();

        // Capitalize field name for export
        const first_char = prop.name[0];
        const capitalized = std.ascii.toUpper(first_char);
        try self.buffer.append(self.allocator, capitalized);
        if (prop.name.len > 1) {
            try self.write(prop.name[1..]);
        }

        try self.write(" ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        // Check for @alias attribute and add JSON tag
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        // Add JSON tag
        try self.write(" `json:\"");
        if (has_alias and alias_name != null) {
            try self.write(alias_name.?);
        } else {
            try self.write(prop.name);
        }
        try self.write("\"`");

        try self.write("\n");
    }

    fn generateEnum(self: *GoGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write enum type definition
        try self.write("type ");
        try self.write(enm.name);
        try self.writeLine(" string");
        try self.writeLine("");

        // Write enum constants
        try self.writeLine("const (");
        self.indent_level += 1;

        for (enm.values.items) |val| {
            try self.generateEnumValue(&val, enm.name);
        }

        self.indent_level -= 1;
        try self.writeLine(")");
    }

    fn generateEnumValue(self: *GoGenerator, val: *const EnumValue, enum_name: []const u8) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write(enum_name);
        try self.write(val.name);
        try self.write(" ");
        try self.write(enum_name);
        try self.write(" = \"");
        try self.write(val.name);
        try self.write("\"\n");
    }

    fn generateFunction(self: *GoGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("// ");
            try self.write(doc);
            try self.write("\n");
        }

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("// Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("// ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write function signature
        try self.write("func ");
        try self.write(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
            try self.write(" ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") (");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(", error) {");

        self.indent_level += 1;
        try self.writeLine("return *new(");
        try self.writeIndent();
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine("), errors.New(\"This is a stub for LLM function\")");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *GoGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const go_type = mapPrimitiveType(prim);
                try self.write(go_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("[]");
                try self.writeTypeAnnotation(inner);
            },
            .optional => |inner| {
                try self.write("*");
                try self.writeTypeAnnotation(inner);
            },
            .union_type => |union_ty| {
                // Go doesn't have union types, use interface{}
                if (union_ty.types.items.len == 2) {
                    // Check if one type is null - if so, use pointer
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.write("*");
                        try self.writeTypeAnnotation(non_null_type.?);
                    } else {
                        try self.write("interface{}");
                    }
                } else {
                    try self.write("interface{}");
                }
            },
            .map => |map| {
                try self.write("map[");
                try self.writeTypeAnnotation(map.key_type);
                try self.write("]");
                try self.writeTypeAnnotation(map.value_type);
            },
            .literal => |lit| {
                // Literals in Go are just their types
                switch (lit) {
                    .string => try self.write("string"),
                    .int => try self.write("int"),
                    .float => try self.write("float64"),
                    .bool => try self.write("bool"),
                    .null_value => try self.write("interface{}"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "string",
            .int => "int",
            .float => "float64",
            .bool => "bool",
            .null_type => "interface{}",
            .image => "interface{}",  // Image type as interface{} for now
            .audio => "interface{}",  // Audio type as interface{} for now
            .video => "interface{}",  // Video type as interface{} for now
            .pdf => "interface{}",    // PDF type as interface{} for now
        };
    }

    fn write(self: *GoGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *GoGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *GoGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "\t");
        }
    }
};

// Go Generator Tests
test "GoGenerator: simple struct" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "type Person struct {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Name string") != null);
}

test "GoGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "type Status string") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "StatusActive Status = \"Active\"") != null);
}

test "GoGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Age *int") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Tags []string") != null);
}

test "GoGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Metadata map[string]string") != null);
}

test "GoGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "func Greet(p Person) (string, error)") != null);
}

test "GoGenerator: field with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = GoGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "Email string `json:\"email_address\"`") != null);
}

/// Ruby code generator
pub const RubyGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) RubyGenerator {
        return RubyGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Ruby code from AST
    pub fn generate(self: *RubyGenerator, tree: *const Ast) !void {
        // Write header with comments
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateClass(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *RubyGenerator) !void {
        try self.writeLine("# Generated by minibaml");
        try self.writeLine("# DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("# frozen_string_literal: true");
        try self.writeLine("");
    }

    fn generateClass(self: *RubyGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write class definition
        try self.write("class ");
        try self.write(class.name);
        try self.writeLine("");

        self.indent_level += 1;

        // Generate attr_accessor for all properties
        if (class.properties.items.len > 0) {
            try self.writeIndent();
            try self.write("attr_accessor ");
            for (class.properties.items, 0..) |prop, i| {
                if (i > 0) try self.write(", ");
                try self.write(":");
                // Check for @alias attribute
                var property_name = prop.name;
                for (prop.attributes.items) |attr| {
                    if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                        if (attr.args.items[0] == .string) {
                            property_name = attr.args.items[0].string;
                            break;
                        }
                    }
                }
                try self.write(property_name);
            }
            try self.write("\n\n");

            // Generate initialize method with type comments
            try self.writeLine("# @param args [Hash] Initialization arguments");
            try self.writeLine("def initialize(**args)");
            self.indent_level += 1;

            for (class.properties.items) |prop| {
                try self.writeIndent();
                try self.write("@");
                // Use alias if present
                var property_name = prop.name;
                for (prop.attributes.items) |attr| {
                    if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                        if (attr.args.items[0] == .string) {
                            property_name = attr.args.items[0].string;
                            break;
                        }
                    }
                }
                try self.write(property_name);
                try self.write(" = args[:");
                try self.write(property_name);
                try self.write("]\n");
            }

            self.indent_level -= 1;
            try self.writeLine("end");
        }

        self.indent_level -= 1;
        try self.writeLine("end");
    }

    fn generateEnum(self: *RubyGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write module definition for enum
        try self.write("module ");
        try self.write(enm.name);
        try self.writeLine("");

        self.indent_level += 1;

        // Generate constants for each value
        for (enm.values.items) |val| {
            try self.generateEnumValue(&val);
        }

        // Generate ALL constant with all values
        try self.writeLine("");
        try self.writeIndent();
        try self.write("ALL = [");
        for (enm.values.items, 0..) |val, i| {
            if (i > 0) try self.write(", ");
            try self.write(val.name);
        }
        try self.write("].freeze\n");

        self.indent_level -= 1;
        try self.writeLine("end");
    }

    fn generateEnumValue(self: *RubyGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(" = '");
        try self.write(val.name);
        try self.write("'.freeze\n");
    }

    fn generateFunction(self: *RubyGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.write("# ");
            try self.write(doc);
            try self.write("\n");
        }

        // Write YARD-style type documentation
        for (func.parameters.items) |param| {
            try self.write("# @param ");
            try self.write(param.name);
            try self.write(" [");
            try self.writeTypeAnnotation(param.type_expr);
            try self.write("]\n");
        }

        try self.write("# @return [");
        try self.writeTypeAnnotation(func.return_type);
        try self.write("]\n");

        // If there's a prompt, add it as a comment
        if (func.prompt) |prompt| {
            try self.writeLine("# Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("# ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write function definition
        try self.write("def ");

        // Convert to snake_case for Ruby convention
        try self.writeSnakeCase(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.write(param.name);
        }

        try self.writeLine(")");

        self.indent_level += 1;
        try self.writeLine("raise NotImplementedError, 'This is a stub for LLM function'");
        self.indent_level -= 1;

        try self.writeLine("end");
    }

    fn writeTypeAnnotation(self: *RubyGenerator, type_expr: *const TypeExpr) !void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const ruby_type = mapPrimitiveType(prim);
                try self.write(ruby_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("Array<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .optional => |inner| {
                try self.writeTypeAnnotation(inner);
                try self.write(", nil");
            },
            .union_type => |union_ty| {
                for (union_ty.types.items, 0..) |ty, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeTypeAnnotation(ty);
                }
            },
            .map => |map| {
                try self.write("Hash{");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(" => ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write("}");
            },
            .literal => |lit| {
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("Integer"),
                    .float => try self.write("Float"),
                    .bool => try self.write("Boolean"),
                    .null_value => try self.write("nil"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "Integer",
            .float => "Float",
            .bool => "Boolean",
            .null_type => "nil",
            .image => "Object",  // Image type as Object for now
            .audio => "Object",  // Audio type as Object for now
            .video => "Object",  // Video type as Object for now
            .pdf => "Object",    // PDF type as Object for now
        };
    }

    fn writeSnakeCase(self: *RubyGenerator, name: []const u8) !void {
        // Convert PascalCase/camelCase to snake_case
        for (name, 0..) |c, i| {
            if (std.ascii.isUpper(c)) {
                if (i > 0) {
                    try self.buffer.append(self.allocator, '_');
                }
                try self.buffer.append(self.allocator, std.ascii.toLower(c));
            } else {
                try self.buffer.append(self.allocator, c);
            }
        }
    }

    fn write(self: *RubyGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *RubyGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *RubyGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "  ");
        }
    }
};

// Ruby Generator Tests
test "RubyGenerator: simple class" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "class Person") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :name") != null);
}

test "RubyGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "module Status") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active = 'Active'.freeze") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "ALL = [Active].freeze") != null);
}

test "RubyGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :age, :tags") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "def initialize") != null);
}

test "RubyGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "def greet(p)") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# @param p [Person]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "# @return [String]") != null);
}

test "RubyGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :metadata") != null);
}

test "RubyGenerator: property with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RubyGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "attr_accessor :email_address") != null);
}

/// Rust code generator
pub const RustGenerator = struct {
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    indent_level: usize,

    pub fn init(allocator: std.mem.Allocator, buffer: *std.ArrayList(u8)) RustGenerator {
        return RustGenerator{
            .allocator = allocator,
            .buffer = buffer,
            .indent_level = 0,
        };
    }

    /// Generate Rust code from AST
    pub fn generate(self: *RustGenerator, tree: *const Ast) !void {
        // Write header with comments and use statements
        try self.writeHeader();

        // Generate code for each declaration
        for (tree.declarations.items) |decl| {
            switch (decl) {
                .class_decl => |class| try self.generateStruct(&class),
                .enum_decl => |enm| try self.generateEnum(&enm),
                .function_decl => |func| try self.generateFunction(&func),
                else => {}, // Skip client, test, generator declarations
            }
            try self.writeLine("");
        }
    }

    fn writeHeader(self: *RustGenerator) !void {
        try self.writeLine("// Generated by minibaml");
        try self.writeLine("// DO NOT EDIT - This file is auto-generated");
        try self.writeLine("");
        try self.writeLine("use serde::{Deserialize, Serialize};");
        try self.writeLine("use std::collections::HashMap;");
        try self.writeLine("use std::error::Error;");
        try self.writeLine("");
    }

    fn generateStruct(self: *RustGenerator, class: *const ClassDecl) !void {
        // Write docstring if present
        if (class.docstring) |doc| {
            try self.writeLine("/// ");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
        }

        // Write derives
        try self.writeLine("#[derive(Debug, Clone, Serialize, Deserialize)]");

        // Write struct definition
        try self.write("pub struct ");
        try self.write(class.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate fields
        for (class.properties.items) |prop| {
            try self.generateField(&prop);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateField(self: *RustGenerator, prop: *const Property) !void {
        // Write docstring if present
        if (prop.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        // Check for @alias attribute and add serde rename
        var has_alias = false;
        var alias_name: ?[]const u8 = null;
        for (prop.attributes.items) |attr| {
            if (std.mem.eql(u8, attr.name, "alias") and attr.args.items.len > 0) {
                if (attr.args.items[0] == .string) {
                    has_alias = true;
                    alias_name = attr.args.items[0].string;
                    break;
                }
            }
        }

        if (has_alias and alias_name != null) {
            try self.writeIndent();
            try self.write("#[serde(rename = \"");
            try self.write(alias_name.?);
            try self.write("\")]\n");
        }

        try self.writeIndent();
        try self.write("pub ");
        try self.writeSnakeCase(prop.name);
        try self.write(": ");

        // Write type annotation
        try self.writeTypeAnnotation(prop.type_expr);

        try self.write(",\n");
    }

    fn generateEnum(self: *RustGenerator, enm: *const EnumDecl) !void {
        // Write docstring if present
        if (enm.docstring) |doc| {
            try self.writeLine("/// ");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
        }

        // Write derives
        try self.writeLine("#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]");

        // Write enum definition
        try self.write("pub enum ");
        try self.write(enm.name);
        try self.writeLine(" {");

        self.indent_level += 1;

        // Generate enum variants
        for (enm.values.items) |val| {
            try self.generateEnumValue(&val);
        }

        self.indent_level -= 1;
        try self.writeLine("}");
    }

    fn generateEnumValue(self: *RustGenerator, val: *const EnumValue) !void {
        // Write docstring if present
        if (val.docstring) |doc| {
            try self.writeIndent();
            try self.write("/// ");
            try self.write(doc);
            try self.write("\n");
        }

        try self.writeIndent();
        try self.write(val.name);
        try self.write(",\n");
    }

    fn generateFunction(self: *RustGenerator, func: *const FunctionDecl) !void {
        // Write docstring if present
        if (func.docstring) |doc| {
            try self.writeLine("/// ");
            try self.writeIndent();
            try self.write(doc);
            try self.write("\n");
        }

        // If there's a prompt, add it as a doc comment
        if (func.prompt) |prompt| {
            try self.writeLine("///");
            try self.writeLine("/// # Prompt:");
            var lines = std.mem.splitSequence(u8, prompt, "\n");
            while (lines.next()) |line| {
                try self.write("/// ");
                try self.write(line);
                try self.write("\n");
            }
        }

        // Write function signature
        try self.write("pub fn ");
        try self.writeSnakeCase(func.name);
        try self.write("(");

        // Write parameters
        for (func.parameters.items, 0..) |param, i| {
            if (i > 0) try self.write(", ");
            try self.writeSnakeCase(param.name);
            try self.write(": ");
            try self.writeTypeAnnotation(param.type_expr);
        }

        try self.write(") -> Result<");
        try self.writeTypeAnnotation(func.return_type);
        try self.writeLine(", Box<dyn Error>> {");

        self.indent_level += 1;
        try self.writeLine("Err(\"This is a stub for LLM function\".into())");
        self.indent_level -= 1;

        try self.writeLine("}");
    }

    fn writeTypeAnnotation(self: *RustGenerator, type_expr: *const TypeExpr) anyerror!void {
        switch (type_expr.*) {
            .primitive => |prim| {
                const rust_type = mapPrimitiveType(prim);
                try self.write(rust_type);
            },
            .named => |name| {
                try self.write(name);
            },
            .array => |inner| {
                try self.write("Vec<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .optional => |inner| {
                try self.write("Option<");
                try self.writeTypeAnnotation(inner);
                try self.write(">");
            },
            .union_type => |union_ty| {
                // Rust doesn't have union types like TypeScript
                // Check if one type is null - if so, use Option
                if (union_ty.types.items.len == 2) {
                    var non_null_type: ?*TypeExpr = null;
                    for (union_ty.types.items) |ty| {
                        if (ty.* != .primitive or ty.primitive != .null_type) {
                            non_null_type = ty;
                            break;
                        }
                    }
                    if (non_null_type != null) {
                        try self.write("Option<");
                        try self.writeTypeAnnotation(non_null_type.?);
                        try self.write(">");
                    } else {
                        // Both are null? Just use unit type
                        try self.write("()");
                    }
                } else {
                    // Multiple non-null types - use Box<dyn Any> as fallback
                    try self.write("Box<dyn std::any::Any>");
                }
            },
            .map => |map| {
                try self.write("HashMap<");
                try self.writeTypeAnnotation(map.key_type);
                try self.write(", ");
                try self.writeTypeAnnotation(map.value_type);
                try self.write(">");
            },
            .literal => |lit| {
                // Literals in Rust are just their types
                switch (lit) {
                    .string => try self.write("String"),
                    .int => try self.write("i64"),
                    .float => try self.write("f64"),
                    .bool => try self.write("bool"),
                    .null_value => try self.write("()"),
                }
            },
        }
    }

    fn mapPrimitiveType(prim: PrimitiveType) []const u8 {
        return switch (prim) {
            .string => "String",
            .int => "i64",
            .float => "f64",
            .bool => "bool",
            .null_type => "()",
            .image => "Vec<u8>",  // Image type as byte array
            .audio => "Vec<u8>",  // Audio type as byte array
            .video => "Vec<u8>",  // Video type as byte array
            .pdf => "Vec<u8>",    // PDF type as byte array
        };
    }

    fn writeSnakeCase(self: *RustGenerator, name: []const u8) !void {
        // Convert PascalCase/camelCase to snake_case
        for (name, 0..) |c, i| {
            if (std.ascii.isUpper(c)) {
                if (i > 0) {
                    try self.buffer.append(self.allocator, '_');
                }
                try self.buffer.append(self.allocator, std.ascii.toLower(c));
            } else {
                try self.buffer.append(self.allocator, c);
            }
        }
    }

    fn write(self: *RustGenerator, text: []const u8) !void {
        try self.buffer.appendSlice(self.allocator, text);
    }

    fn writeLine(self: *RustGenerator, text: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(self.allocator, text);
        try self.buffer.append(self.allocator, '\n');
    }

    fn writeIndent(self: *RustGenerator) !void {
        var i: usize = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.buffer.appendSlice(self.allocator, "    ");
        }
    }
};

// Rust Generator Tests
test "RustGenerator: simple struct" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add a property: name string
    const name_type = try allocator.create(TypeExpr);
    name_type.* = .{ .primitive = .string };

    var attributes = std.ArrayList(ast.Attribute).init(allocator);
    defer attributes.deinit(allocator);

    const name_prop = Property{
        .name = "name",
        .type_expr = name_type,
        .attributes = attributes,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, name_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub struct Person {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "pub name: String,") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "#[derive(Debug, Clone, Serialize, Deserialize)]") != null);
}

test "RustGenerator: simple enum" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var enum_decl = EnumDecl.init(allocator, "Status", .{ .line = 1, .column = 1 });
    defer enum_decl.deinit(allocator);

    const active = EnumValue{
        .name = "Active",
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try enum_decl.values.append(allocator, active);

    try ast_tree.declarations.append(allocator, .{ .enum_decl = enum_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub enum Status {") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "Active,") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]") != null);
}

test "RustGenerator: optional and array types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: age int?
    const int_type = try allocator.create(TypeExpr);
    int_type.* = .{ .primitive = .int };

    const age_type = try allocator.create(TypeExpr);
    age_type.* = .{ .optional = int_type };

    const age_prop = Property{
        .name = "age",
        .type_expr = age_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, age_prop);

    // Add property: tags string[]
    const str_type = try allocator.create(TypeExpr);
    str_type.* = .{ .primitive = .string };

    const tags_type = try allocator.create(TypeExpr);
    tags_type.* = .{ .array = str_type };

    const tags_prop = Property{
        .name = "tags",
        .type_expr = tags_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 3, .column = 3 },
    };
    try class_decl.properties.append(allocator, tags_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub age: Option<i64>,") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "pub tags: Vec<String>,") != null);
}

test "RustGenerator: map types" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: metadata map<string, string>
    const key_type = try allocator.create(TypeExpr);
    key_type.* = .{ .primitive = .string };

    const value_type = try allocator.create(TypeExpr);
    value_type.* = .{ .primitive = .string };

    const map_type = try allocator.create(TypeExpr);
    map_type.* = .{ .map = .{ .key_type = key_type, .value_type = value_type } };

    const meta_prop = Property{
        .name = "metadata",
        .type_expr = map_type,
        .attributes = std.ArrayList(ast.Attribute).init(allocator),
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, meta_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub metadata: HashMap<String, String>,") != null);
}

test "RustGenerator: function with parameters" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var func_decl = FunctionDecl.init(allocator, "Greet", .{ .line = 1, .column = 1 });
    defer func_decl.deinit(allocator);

    // Parameter: p: Person
    const person_type = try allocator.create(TypeExpr);
    person_type.* = .{ .named = "Person" };

    const param = Parameter{
        .name = "p",
        .type_expr = person_type,
        .location = .{ .line = 1, .column = 15 },
    };
    try func_decl.parameters.append(allocator, param);

    // Return type: string
    const return_type = try allocator.create(TypeExpr);
    return_type.* = .{ .primitive = .string };
    func_decl.return_type = return_type;

    try ast_tree.declarations.append(allocator, .{ .function_decl = func_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "pub fn greet(p: Person) -> Result<String, Box<dyn Error>> {") != null);
}

test "RustGenerator: field with alias" {
    const allocator = std.testing.allocator;

    var ast_tree = Ast.init(allocator);
    defer ast_tree.deinit();

    var class_decl = ClassDecl.init(allocator, "Person", .{ .line = 1, .column = 1 });
    defer class_decl.deinit(allocator);

    // Add property: email string @alias("email_address")
    const email_type = try allocator.create(TypeExpr);
    email_type.* = .{ .primitive = .string };

    var attr = ast.Attribute{
        .name = "alias",
        .is_class_level = false,
        .args = std.ArrayList(ast.Value).init(allocator),
        .location = .{ .line = 2, .column = 10 },
    };
    try attr.args.append(allocator, .{ .string = "email_address" });

    var attrs = std.ArrayList(ast.Attribute).init(allocator);
    try attrs.append(allocator, attr);

    const email_prop = Property{
        .name = "email",
        .type_expr = email_type,
        .attributes = attrs,
        .docstring = null,
        .location = .{ .line = 2, .column = 3 },
    };
    try class_decl.properties.append(allocator, email_prop);

    try ast_tree.declarations.append(allocator, .{ .class_decl = class_decl });

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    var gen = RustGenerator.init(allocator, &buffer);
    try gen.generate(&ast_tree);

    const output = buffer.items;
    try std.testing.expect(std.mem.indexOf(u8, output, "#[serde(rename = \"email_address\")]") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "pub email: String,") != null);
}
